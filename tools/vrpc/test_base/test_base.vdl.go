// This file was auto-generated by the veyron vdl tool.
// Source: test_base.vdl

package test_base

import (
	// VDL system imports
	"io"
	"v.io/v23"
	"v.io/v23/context"
	"v.io/v23/ipc"
	"v.io/v23/vdl"
)

type Struct struct {
	X int32
	Y int32
}

func (Struct) __VDLReflect(struct {
	Name string "v.io/core/veyron/tools/vrpc/test_base.Struct"
}) {
}

type Array2Int [2]int32

func (Array2Int) __VDLReflect(struct {
	Name string "v.io/core/veyron/tools/vrpc/test_base.Array2Int"
}) {
}

func init() {
	vdl.Register((*Struct)(nil))
	vdl.Register((*Array2Int)(nil))
}

// TypeTesterClientMethods is the client interface
// containing TypeTester methods.
//
// TypeTester methods are listed in alphabetical order, to make it easier to
// test Signature output, which sorts methods alphabetically.
type TypeTesterClientMethods interface {
	// Methods to test support for primitive types.
	EchoBool(ctx *context.T, I1 bool, opts ...ipc.CallOpt) (O1 bool, err error)
	EchoFloat32(ctx *context.T, I1 float32, opts ...ipc.CallOpt) (O1 float32, err error)
	EchoFloat64(ctx *context.T, I1 float64, opts ...ipc.CallOpt) (O1 float64, err error)
	EchoInt32(ctx *context.T, I1 int32, opts ...ipc.CallOpt) (O1 int32, err error)
	EchoInt64(ctx *context.T, I1 int64, opts ...ipc.CallOpt) (O1 int64, err error)
	EchoString(ctx *context.T, I1 string, opts ...ipc.CallOpt) (O1 string, err error)
	EchoByte(ctx *context.T, I1 byte, opts ...ipc.CallOpt) (O1 byte, err error)
	EchoUint32(ctx *context.T, I1 uint32, opts ...ipc.CallOpt) (O1 uint32, err error)
	EchoUint64(ctx *context.T, I1 uint64, opts ...ipc.CallOpt) (O1 uint64, err error)
	// Methods to test support for composite types.
	XEchoArray(ctx *context.T, I1 Array2Int, opts ...ipc.CallOpt) (O1 Array2Int, err error)
	XEchoMap(ctx *context.T, I1 map[int32]string, opts ...ipc.CallOpt) (O1 map[int32]string, err error)
	XEchoSet(ctx *context.T, I1 map[int32]struct{}, opts ...ipc.CallOpt) (O1 map[int32]struct{}, err error)
	XEchoSlice(ctx *context.T, I1 []int32, opts ...ipc.CallOpt) (O1 []int32, err error)
	XEchoStruct(ctx *context.T, I1 Struct, opts ...ipc.CallOpt) (O1 Struct, err error)
	// Methods to test support for different number of arguments.
	YMultiArg(ctx *context.T, I1 int32, I2 int32, opts ...ipc.CallOpt) (O1 int32, O2 int32, err error)
	YNoArgs(*context.T, ...ipc.CallOpt) error
	// Methods to test support for streaming.
	ZStream(ctx *context.T, NumStreamItems int32, StreamItem bool, opts ...ipc.CallOpt) (TypeTesterZStreamCall, error)
}

// TypeTesterClientStub adds universal methods to TypeTesterClientMethods.
type TypeTesterClientStub interface {
	TypeTesterClientMethods
	ipc.UniversalServiceMethods
}

// TypeTesterClient returns a client stub for TypeTester.
func TypeTesterClient(name string, opts ...ipc.BindOpt) TypeTesterClientStub {
	var client ipc.Client
	for _, opt := range opts {
		if clientOpt, ok := opt.(ipc.Client); ok {
			client = clientOpt
		}
	}
	return implTypeTesterClientStub{name, client}
}

type implTypeTesterClientStub struct {
	name   string
	client ipc.Client
}

func (c implTypeTesterClientStub) c(ctx *context.T) ipc.Client {
	if c.client != nil {
		return c.client
	}
	return v23.GetClient(ctx)
}

func (c implTypeTesterClientStub) EchoBool(ctx *context.T, i0 bool, opts ...ipc.CallOpt) (o0 bool, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoBool", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoFloat32(ctx *context.T, i0 float32, opts ...ipc.CallOpt) (o0 float32, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoFloat32", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoFloat64(ctx *context.T, i0 float64, opts ...ipc.CallOpt) (o0 float64, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoFloat64", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoInt32(ctx *context.T, i0 int32, opts ...ipc.CallOpt) (o0 int32, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoInt32", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoInt64(ctx *context.T, i0 int64, opts ...ipc.CallOpt) (o0 int64, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoInt64", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoString(ctx *context.T, i0 string, opts ...ipc.CallOpt) (o0 string, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoString", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoByte(ctx *context.T, i0 byte, opts ...ipc.CallOpt) (o0 byte, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoByte", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoUint32(ctx *context.T, i0 uint32, opts ...ipc.CallOpt) (o0 uint32, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoUint32", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoUint64(ctx *context.T, i0 uint64, opts ...ipc.CallOpt) (o0 uint64, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoUint64", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) XEchoArray(ctx *context.T, i0 Array2Int, opts ...ipc.CallOpt) (o0 Array2Int, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "XEchoArray", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) XEchoMap(ctx *context.T, i0 map[int32]string, opts ...ipc.CallOpt) (o0 map[int32]string, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "XEchoMap", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) XEchoSet(ctx *context.T, i0 map[int32]struct{}, opts ...ipc.CallOpt) (o0 map[int32]struct{}, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "XEchoSet", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) XEchoSlice(ctx *context.T, i0 []int32, opts ...ipc.CallOpt) (o0 []int32, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "XEchoSlice", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) XEchoStruct(ctx *context.T, i0 Struct, opts ...ipc.CallOpt) (o0 Struct, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "XEchoStruct", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) YMultiArg(ctx *context.T, i0 int32, i1 int32, opts ...ipc.CallOpt) (o0 int32, o1 int32, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "YMultiArg", []interface{}{i0, i1}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0, &o1)
	return
}

func (c implTypeTesterClientStub) YNoArgs(ctx *context.T, opts ...ipc.CallOpt) (err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "YNoArgs", nil, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implTypeTesterClientStub) ZStream(ctx *context.T, i0 int32, i1 bool, opts ...ipc.CallOpt) (ocall TypeTesterZStreamCall, err error) {
	var call ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "ZStream", []interface{}{i0, i1}, opts...); err != nil {
		return
	}
	ocall = &implTypeTesterZStreamCall{Call: call}
	return
}

// TypeTesterZStreamClientStream is the client stream for TypeTester.ZStream.
type TypeTesterZStreamClientStream interface {
	// RecvStream returns the receiver side of the TypeTester.ZStream client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() bool
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// TypeTesterZStreamCall represents the call returned from TypeTester.ZStream.
type TypeTesterZStreamCall interface {
	TypeTesterZStreamClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implTypeTesterZStreamCall struct {
	ipc.Call
	valRecv bool
	errRecv error
}

func (c *implTypeTesterZStreamCall) RecvStream() interface {
	Advance() bool
	Value() bool
	Err() error
} {
	return implTypeTesterZStreamCallRecv{c}
}

type implTypeTesterZStreamCallRecv struct {
	c *implTypeTesterZStreamCall
}

func (c implTypeTesterZStreamCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implTypeTesterZStreamCallRecv) Value() bool {
	return c.c.valRecv
}
func (c implTypeTesterZStreamCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implTypeTesterZStreamCall) Finish() (err error) {
	err = c.Call.Finish()
	return
}

// TypeTesterServerMethods is the interface a server writer
// implements for TypeTester.
//
// TypeTester methods are listed in alphabetical order, to make it easier to
// test Signature output, which sorts methods alphabetically.
type TypeTesterServerMethods interface {
	// Methods to test support for primitive types.
	EchoBool(ctx ipc.ServerContext, I1 bool) (O1 bool, err error)
	EchoFloat32(ctx ipc.ServerContext, I1 float32) (O1 float32, err error)
	EchoFloat64(ctx ipc.ServerContext, I1 float64) (O1 float64, err error)
	EchoInt32(ctx ipc.ServerContext, I1 int32) (O1 int32, err error)
	EchoInt64(ctx ipc.ServerContext, I1 int64) (O1 int64, err error)
	EchoString(ctx ipc.ServerContext, I1 string) (O1 string, err error)
	EchoByte(ctx ipc.ServerContext, I1 byte) (O1 byte, err error)
	EchoUint32(ctx ipc.ServerContext, I1 uint32) (O1 uint32, err error)
	EchoUint64(ctx ipc.ServerContext, I1 uint64) (O1 uint64, err error)
	// Methods to test support for composite types.
	XEchoArray(ctx ipc.ServerContext, I1 Array2Int) (O1 Array2Int, err error)
	XEchoMap(ctx ipc.ServerContext, I1 map[int32]string) (O1 map[int32]string, err error)
	XEchoSet(ctx ipc.ServerContext, I1 map[int32]struct{}) (O1 map[int32]struct{}, err error)
	XEchoSlice(ctx ipc.ServerContext, I1 []int32) (O1 []int32, err error)
	XEchoStruct(ctx ipc.ServerContext, I1 Struct) (O1 Struct, err error)
	// Methods to test support for different number of arguments.
	YMultiArg(ctx ipc.ServerContext, I1 int32, I2 int32) (O1 int32, O2 int32, err error)
	YNoArgs(ipc.ServerContext) error
	// Methods to test support for streaming.
	ZStream(ctx TypeTesterZStreamContext, NumStreamItems int32, StreamItem bool) error
}

// TypeTesterServerStubMethods is the server interface containing
// TypeTester methods, as expected by ipc.Server.
// The only difference between this interface and TypeTesterServerMethods
// is the streaming methods.
type TypeTesterServerStubMethods interface {
	// Methods to test support for primitive types.
	EchoBool(ctx ipc.ServerContext, I1 bool) (O1 bool, err error)
	EchoFloat32(ctx ipc.ServerContext, I1 float32) (O1 float32, err error)
	EchoFloat64(ctx ipc.ServerContext, I1 float64) (O1 float64, err error)
	EchoInt32(ctx ipc.ServerContext, I1 int32) (O1 int32, err error)
	EchoInt64(ctx ipc.ServerContext, I1 int64) (O1 int64, err error)
	EchoString(ctx ipc.ServerContext, I1 string) (O1 string, err error)
	EchoByte(ctx ipc.ServerContext, I1 byte) (O1 byte, err error)
	EchoUint32(ctx ipc.ServerContext, I1 uint32) (O1 uint32, err error)
	EchoUint64(ctx ipc.ServerContext, I1 uint64) (O1 uint64, err error)
	// Methods to test support for composite types.
	XEchoArray(ctx ipc.ServerContext, I1 Array2Int) (O1 Array2Int, err error)
	XEchoMap(ctx ipc.ServerContext, I1 map[int32]string) (O1 map[int32]string, err error)
	XEchoSet(ctx ipc.ServerContext, I1 map[int32]struct{}) (O1 map[int32]struct{}, err error)
	XEchoSlice(ctx ipc.ServerContext, I1 []int32) (O1 []int32, err error)
	XEchoStruct(ctx ipc.ServerContext, I1 Struct) (O1 Struct, err error)
	// Methods to test support for different number of arguments.
	YMultiArg(ctx ipc.ServerContext, I1 int32, I2 int32) (O1 int32, O2 int32, err error)
	YNoArgs(ipc.ServerContext) error
	// Methods to test support for streaming.
	ZStream(ctx *TypeTesterZStreamContextStub, NumStreamItems int32, StreamItem bool) error
}

// TypeTesterServerStub adds universal methods to TypeTesterServerStubMethods.
type TypeTesterServerStub interface {
	TypeTesterServerStubMethods
	// Describe the TypeTester interfaces.
	Describe__() []ipc.InterfaceDesc
}

// TypeTesterServer returns a server stub for TypeTester.
// It converts an implementation of TypeTesterServerMethods into
// an object that may be used by ipc.Server.
func TypeTesterServer(impl TypeTesterServerMethods) TypeTesterServerStub {
	stub := implTypeTesterServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := ipc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := ipc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implTypeTesterServerStub struct {
	impl TypeTesterServerMethods
	gs   *ipc.GlobState
}

func (s implTypeTesterServerStub) EchoBool(ctx ipc.ServerContext, i0 bool) (bool, error) {
	return s.impl.EchoBool(ctx, i0)
}

func (s implTypeTesterServerStub) EchoFloat32(ctx ipc.ServerContext, i0 float32) (float32, error) {
	return s.impl.EchoFloat32(ctx, i0)
}

func (s implTypeTesterServerStub) EchoFloat64(ctx ipc.ServerContext, i0 float64) (float64, error) {
	return s.impl.EchoFloat64(ctx, i0)
}

func (s implTypeTesterServerStub) EchoInt32(ctx ipc.ServerContext, i0 int32) (int32, error) {
	return s.impl.EchoInt32(ctx, i0)
}

func (s implTypeTesterServerStub) EchoInt64(ctx ipc.ServerContext, i0 int64) (int64, error) {
	return s.impl.EchoInt64(ctx, i0)
}

func (s implTypeTesterServerStub) EchoString(ctx ipc.ServerContext, i0 string) (string, error) {
	return s.impl.EchoString(ctx, i0)
}

func (s implTypeTesterServerStub) EchoByte(ctx ipc.ServerContext, i0 byte) (byte, error) {
	return s.impl.EchoByte(ctx, i0)
}

func (s implTypeTesterServerStub) EchoUint32(ctx ipc.ServerContext, i0 uint32) (uint32, error) {
	return s.impl.EchoUint32(ctx, i0)
}

func (s implTypeTesterServerStub) EchoUint64(ctx ipc.ServerContext, i0 uint64) (uint64, error) {
	return s.impl.EchoUint64(ctx, i0)
}

func (s implTypeTesterServerStub) XEchoArray(ctx ipc.ServerContext, i0 Array2Int) (Array2Int, error) {
	return s.impl.XEchoArray(ctx, i0)
}

func (s implTypeTesterServerStub) XEchoMap(ctx ipc.ServerContext, i0 map[int32]string) (map[int32]string, error) {
	return s.impl.XEchoMap(ctx, i0)
}

func (s implTypeTesterServerStub) XEchoSet(ctx ipc.ServerContext, i0 map[int32]struct{}) (map[int32]struct{}, error) {
	return s.impl.XEchoSet(ctx, i0)
}

func (s implTypeTesterServerStub) XEchoSlice(ctx ipc.ServerContext, i0 []int32) ([]int32, error) {
	return s.impl.XEchoSlice(ctx, i0)
}

func (s implTypeTesterServerStub) XEchoStruct(ctx ipc.ServerContext, i0 Struct) (Struct, error) {
	return s.impl.XEchoStruct(ctx, i0)
}

func (s implTypeTesterServerStub) YMultiArg(ctx ipc.ServerContext, i0 int32, i1 int32) (int32, int32, error) {
	return s.impl.YMultiArg(ctx, i0, i1)
}

func (s implTypeTesterServerStub) YNoArgs(ctx ipc.ServerContext) error {
	return s.impl.YNoArgs(ctx)
}

func (s implTypeTesterServerStub) ZStream(ctx *TypeTesterZStreamContextStub, i0 int32, i1 bool) error {
	return s.impl.ZStream(ctx, i0, i1)
}

func (s implTypeTesterServerStub) Globber() *ipc.GlobState {
	return s.gs
}

func (s implTypeTesterServerStub) Describe__() []ipc.InterfaceDesc {
	return []ipc.InterfaceDesc{TypeTesterDesc}
}

// TypeTesterDesc describes the TypeTester interface.
var TypeTesterDesc ipc.InterfaceDesc = descTypeTester

// descTypeTester hides the desc to keep godoc clean.
var descTypeTester = ipc.InterfaceDesc{
	Name:    "TypeTester",
	PkgPath: "v.io/core/veyron/tools/vrpc/test_base",
	Doc:     "// TypeTester methods are listed in alphabetical order, to make it easier to\n// test Signature output, which sorts methods alphabetically.",
	Methods: []ipc.MethodDesc{
		{
			Name: "EchoBool",
			Doc:  "// Methods to test support for primitive types.",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // bool
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // bool
			},
		},
		{
			Name: "EchoFloat32",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // float32
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // float32
			},
		},
		{
			Name: "EchoFloat64",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // float64
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // float64
			},
		},
		{
			Name: "EchoInt32",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // int32
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // int32
			},
		},
		{
			Name: "EchoInt64",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // int64
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // int64
			},
		},
		{
			Name: "EchoString",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // string
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // string
			},
		},
		{
			Name: "EchoByte",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // byte
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // byte
			},
		},
		{
			Name: "EchoUint32",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // uint32
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // uint32
			},
		},
		{
			Name: "EchoUint64",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // uint64
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // uint64
			},
		},
		{
			Name: "XEchoArray",
			Doc:  "// Methods to test support for composite types.",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // Array2Int
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // Array2Int
			},
		},
		{
			Name: "XEchoMap",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // map[int32]string
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // map[int32]string
			},
		},
		{
			Name: "XEchoSet",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // map[int32]struct{}
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // map[int32]struct{}
			},
		},
		{
			Name: "XEchoSlice",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // []int32
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // []int32
			},
		},
		{
			Name: "XEchoStruct",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // Struct
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // Struct
			},
		},
		{
			Name: "YMultiArg",
			Doc:  "// Methods to test support for different number of arguments.",
			InArgs: []ipc.ArgDesc{
				{"I1", ``}, // int32
				{"I2", ``}, // int32
			},
			OutArgs: []ipc.ArgDesc{
				{"O1", ``}, // int32
				{"O2", ``}, // int32
			},
		},
		{
			Name: "YNoArgs",
		},
		{
			Name: "ZStream",
			Doc:  "// Methods to test support for streaming.",
			InArgs: []ipc.ArgDesc{
				{"NumStreamItems", ``}, // int32
				{"StreamItem", ``},     // bool
			},
		},
	},
}

// TypeTesterZStreamServerStream is the server stream for TypeTester.ZStream.
type TypeTesterZStreamServerStream interface {
	// SendStream returns the send side of the TypeTester.ZStream server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item bool) error
	}
}

// TypeTesterZStreamContext represents the context passed to TypeTester.ZStream.
type TypeTesterZStreamContext interface {
	ipc.ServerContext
	TypeTesterZStreamServerStream
}

// TypeTesterZStreamContextStub is a wrapper that converts ipc.StreamServerCall into
// a typesafe stub that implements TypeTesterZStreamContext.
type TypeTesterZStreamContextStub struct {
	ipc.StreamServerCall
}

// Init initializes TypeTesterZStreamContextStub from ipc.StreamServerCall.
func (s *TypeTesterZStreamContextStub) Init(call ipc.StreamServerCall) {
	s.StreamServerCall = call
}

// SendStream returns the send side of the TypeTester.ZStream server stream.
func (s *TypeTesterZStreamContextStub) SendStream() interface {
	Send(item bool) error
} {
	return implTypeTesterZStreamContextSend{s}
}

type implTypeTesterZStreamContextSend struct {
	s *TypeTesterZStreamContextStub
}

func (s implTypeTesterZStreamContextSend) Send(item bool) error {
	return s.s.Send(item)
}
