#
# Simple example to show how names work and are used both without
# and with a mount table.
#

# A 'stand-alone' server
clockServer "" ""
set STAND_ALONE_CLOCK_NAME=$NAME

set N=$STAND_ALONE_CLOCK_NAME
print "Stand alone clock server at" $N
time $N "Using $N"
set N=/$ADDR
time $N "Using $N"

# Run a root MountTable.
rootMT
set ROOT_ADDR=$MT_ADDR ROOT_NAME=$MT_NAME
print ""
print "Root MountTable at $ROOT_NAME"

clockServer $MT_NAME clock
set CLOCK_NAME=/$ADDR
print "Running Clock Server at $CLOCK_NAME"

# Still bypassing the MountTable
time $CLOCK_NAME bar

# Now, let's use the MountTable
setLocalRoots $ROOT_NAME

set N=clock
resolve $N
print $N -> $R0

set N=/$ROOT_ADDR/clock
resolve $N
print $N -> $R0

# ls * returns clock
ls *
# ls ... returns "" and clock - i.e two items. Is this a bug?
ls ...

# These all behave as above
lsmt $ROOT_NAME *
lsmt $ROOT_NAME ...

# Conclusion: some of this behaviour seems a little awkward. In particular:
#
# The client neeeds to use a different form of the name depending on whether
# a MountTable is used or not. If a MountTable is not used, then the internal
# 'suffix' (/mt) in the examples above must be used. If a MountTable is used
# then the internal suffix must not be included in the name.
#
# ls ... seems to always return an extra, zero length, string as entry
#
