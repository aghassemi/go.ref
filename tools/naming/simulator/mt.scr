#
# Example showing multiple mount tables, servers and globing
#

rootMT
set ROOT_MT_NAME=$MT_NAME ROOT_MT_ADDR=$MT_ADDR
set ROOT=$ROOT_MT_NAME

nodeMT $ROOT usa
set USA_MT=$MT_NAME

nodeMT $USA_MT "palo alto"
set PA_MT=$MT_NAME


print "ROOT MT" $ROOT
print "USA MT" $USA_MT
print "Palo Alto MT" $PA_MT

print "--------- Resolve ROOT, ROOT/usa, ROOT/usa/palo alto"
print "--------- Each should return a different address"
resolve $ROOT
resolve $ROOT/usa
resolve "$ROOT/usa/palo alto"

print "--------- ResolveMT ROOT, ROOT/usa - should return the ROOT MT"
resolveMT $ROOT
resolveMT $ROOT/usa

print "--------- ResolveMT ROOT/usa/palo alto/bar should return the palo alto MT"
resolveMT "$ROOT/usa/palo alto/bar"

# should return a complete hiearchy....
setLocalRoots $ROOT
print "--------- setLocalRoots to global root"
print "--------- ls ..."
ls ...
print "--------- ls *"
ls *

print "--------- setLocalRoots to usa"
setLocalRoots $USA_MT
ls ...

print "--------- setLocalRoots to palo alto"
setLocalRoots $PA_MT
ls ...

nodeMT $ROOT uk
set UK_MT=$MT_NAME

nodeMT $UK_MT "cambridge"
set CAM_MT=$MT_NAME

setLocalRoots $ROOT
ls ...
setLocalRoots $UK_MT
ls ...
setLocalRoots $CAM_MT
ls ...

# Create a MountTable tree without using the internal 'mt' suffix as in the
# examples above.
nodeMT $ROOT "france"
set FRANCE_MT=$MT_NAME
nodeMT $FRANCE_MT "paris"
setLocalRoots $ROOT
ls ...

# Conclusion: some of this behaviour seems a little awkward. In particular:
#
# ls using the local namespace on a rooted name doesn't seem to work either,
# thus making it impossible to see the whole name space without setting the
# local namespace's root which will clearly cause problems for concurrent
# clients.
#




