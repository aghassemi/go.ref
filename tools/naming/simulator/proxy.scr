
cache off

set localaddr=--veyron.tcp.address=127.0.0.1:0

root -- $localaddr
eval $_
set root=$MT_NAME
set NAMESPACE_ROOT=$root
setRoots $NAMESPACE_ROOT

# run a non-proxied echo server
echoServer -- $localaddr noproxy echo/noproxy
set esnp=$_
eval $esnp
set NP_ECHOS_NAME=$NAME
eval $esnp
set NP_ECHOS_ADDR=$ADDR


# run a proxy server
proxyd -- $localaddr p1
set proxy=$_
# PROXY_ADDR=<address of proxy>
eval $proxy
# PROXY_NAME=<name of proxy>
eval $proxy
read $proxy
splitEP $PROXY_ADDR
assert $PN 7
set PROXY_ADDR=$P2
set PROXY_RID=$P3


# TODO(cnicolaou): figure out why ls appears to run slowly when a proxy is
# running, maybe a problem with the mount table.
#ls ...
#set l=$_
#eval $l
#assert $RN 3
#wait $l

echoServer -- $localaddr --veyron.proxy=p1 withproxy echo/withproxy
set eswp=$_
eval $eswp
set ECHOS_NAME=$NAME
eval $eswp
set ECHOS_ADDR=$ADDR
splitEP $ADDR
set ECHOS_RID=$P3

#ls ...
#set l=$_
#eval $l
#assert $RN 4
#wait $l

print "root mt:" $NAMESPACE_ROOT
print "proxy:" $PROXY_ADDR
print "no proxy: " $NP_ECHOS_ADDR
print "with proxy: " $ECHOS_ADDR
# The ipc.Server implementation publishes the proxy supplied address and
# the local address in the mount table
resolve echo/withproxy
set rs=$_
eval $rs
assert $RN 4
eval $rs
set ep1=$R0
eval $rs
set ep2=$R1
eval $rs
set ep3=$R2
eval $rs
set ep4=$R3

splitEP $ep1
assert $PN 7
set ep1_addr=$P2
set rid=$P3
splitEP $ep2
set ep2_addr=$P2
splitEP $ep3
set ep3_addr=$P2
splitEP $ep4
set ep4_addr=$P2

assertOneOf $PROXY_ADDR $ep1_addr $ep2_addr $ep3_addr $ep4_addr
assert $rid $ECHOS_RID

ls -- -l echo/withproxy
wait $_
ls -- -l echo/noproxy
wait $_

echoClient echo/withproxy "ohh"
set ec=$_
read $ec l
assert $l "withproxy: ohh"

stop $eswp
stop $esnp
stop $proxy

