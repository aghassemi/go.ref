// This file was auto-generated by the vanadium vdl tool.
// Source: test_base.vdl

package test_base

import (
	// VDL system imports
	"io"
	"v.io/v23"
	"v.io/v23/context"
	"v.io/v23/rpc"
	"v.io/v23/vdl"
)

type Struct struct {
	X int32
	Y int32
}

func (Struct) __VDLReflect(struct {
	Name string "v.io/x/ref/cmd/vrpc/test_base.Struct"
}) {
}

type Array2Int [2]int32

func (Array2Int) __VDLReflect(struct {
	Name string "v.io/x/ref/cmd/vrpc/test_base.Array2Int"
}) {
}

func init() {
	vdl.Register((*Struct)(nil))
	vdl.Register((*Array2Int)(nil))
}

// TypeTesterClientMethods is the client interface
// containing TypeTester methods.
//
// TypeTester methods are listed in alphabetical order, to make it easier to
// test Signature output, which sorts methods alphabetically.
type TypeTesterClientMethods interface {
	// Methods to test support for primitive types.
	EchoBool(ctx *context.T, I1 bool, opts ...rpc.CallOpt) (O1 bool, err error)
	EchoFloat32(ctx *context.T, I1 float32, opts ...rpc.CallOpt) (O1 float32, err error)
	EchoFloat64(ctx *context.T, I1 float64, opts ...rpc.CallOpt) (O1 float64, err error)
	EchoInt32(ctx *context.T, I1 int32, opts ...rpc.CallOpt) (O1 int32, err error)
	EchoInt64(ctx *context.T, I1 int64, opts ...rpc.CallOpt) (O1 int64, err error)
	EchoString(ctx *context.T, I1 string, opts ...rpc.CallOpt) (O1 string, err error)
	EchoByte(ctx *context.T, I1 byte, opts ...rpc.CallOpt) (O1 byte, err error)
	EchoUint32(ctx *context.T, I1 uint32, opts ...rpc.CallOpt) (O1 uint32, err error)
	EchoUint64(ctx *context.T, I1 uint64, opts ...rpc.CallOpt) (O1 uint64, err error)
	// Methods to test support for composite types.
	XEchoArray(ctx *context.T, I1 Array2Int, opts ...rpc.CallOpt) (O1 Array2Int, err error)
	XEchoMap(ctx *context.T, I1 map[int32]string, opts ...rpc.CallOpt) (O1 map[int32]string, err error)
	XEchoSet(ctx *context.T, I1 map[int32]struct{}, opts ...rpc.CallOpt) (O1 map[int32]struct{}, err error)
	XEchoSlice(ctx *context.T, I1 []int32, opts ...rpc.CallOpt) (O1 []int32, err error)
	XEchoStruct(ctx *context.T, I1 Struct, opts ...rpc.CallOpt) (O1 Struct, err error)
	// Methods to test support for different number of arguments.
	YMultiArg(ctx *context.T, I1 int32, I2 int32, opts ...rpc.CallOpt) (O1 int32, O2 int32, err error)
	YNoArgs(*context.T, ...rpc.CallOpt) error
	// Methods to test support for streaming.
	ZStream(ctx *context.T, NumStreamItems int32, StreamItem bool, opts ...rpc.CallOpt) (TypeTesterZStreamClientCall, error)
}

// TypeTesterClientStub adds universal methods to TypeTesterClientMethods.
type TypeTesterClientStub interface {
	TypeTesterClientMethods
	rpc.UniversalServiceMethods
}

// TypeTesterClient returns a client stub for TypeTester.
func TypeTesterClient(name string, opts ...rpc.BindOpt) TypeTesterClientStub {
	var client rpc.Client
	for _, opt := range opts {
		if clientOpt, ok := opt.(rpc.Client); ok {
			client = clientOpt
		}
	}
	return implTypeTesterClientStub{name, client}
}

type implTypeTesterClientStub struct {
	name   string
	client rpc.Client
}

func (c implTypeTesterClientStub) c(ctx *context.T) rpc.Client {
	if c.client != nil {
		return c.client
	}
	return v23.GetClient(ctx)
}

func (c implTypeTesterClientStub) EchoBool(ctx *context.T, i0 bool, opts ...rpc.CallOpt) (o0 bool, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoBool", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoFloat32(ctx *context.T, i0 float32, opts ...rpc.CallOpt) (o0 float32, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoFloat32", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoFloat64(ctx *context.T, i0 float64, opts ...rpc.CallOpt) (o0 float64, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoFloat64", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoInt32(ctx *context.T, i0 int32, opts ...rpc.CallOpt) (o0 int32, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoInt32", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoInt64(ctx *context.T, i0 int64, opts ...rpc.CallOpt) (o0 int64, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoInt64", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoString(ctx *context.T, i0 string, opts ...rpc.CallOpt) (o0 string, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoString", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoByte(ctx *context.T, i0 byte, opts ...rpc.CallOpt) (o0 byte, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoByte", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoUint32(ctx *context.T, i0 uint32, opts ...rpc.CallOpt) (o0 uint32, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoUint32", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) EchoUint64(ctx *context.T, i0 uint64, opts ...rpc.CallOpt) (o0 uint64, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "EchoUint64", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) XEchoArray(ctx *context.T, i0 Array2Int, opts ...rpc.CallOpt) (o0 Array2Int, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "XEchoArray", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) XEchoMap(ctx *context.T, i0 map[int32]string, opts ...rpc.CallOpt) (o0 map[int32]string, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "XEchoMap", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) XEchoSet(ctx *context.T, i0 map[int32]struct{}, opts ...rpc.CallOpt) (o0 map[int32]struct{}, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "XEchoSet", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) XEchoSlice(ctx *context.T, i0 []int32, opts ...rpc.CallOpt) (o0 []int32, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "XEchoSlice", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) XEchoStruct(ctx *context.T, i0 Struct, opts ...rpc.CallOpt) (o0 Struct, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "XEchoStruct", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implTypeTesterClientStub) YMultiArg(ctx *context.T, i0 int32, i1 int32, opts ...rpc.CallOpt) (o0 int32, o1 int32, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "YMultiArg", []interface{}{i0, i1}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0, &o1)
	return
}

func (c implTypeTesterClientStub) YNoArgs(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "YNoArgs", nil, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implTypeTesterClientStub) ZStream(ctx *context.T, i0 int32, i1 bool, opts ...rpc.CallOpt) (ocall TypeTesterZStreamClientCall, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "ZStream", []interface{}{i0, i1}, opts...); err != nil {
		return
	}
	ocall = &implTypeTesterZStreamClientCall{ClientCall: call}
	return
}

// TypeTesterZStreamClientStream is the client stream for TypeTester.ZStream.
type TypeTesterZStreamClientStream interface {
	// RecvStream returns the receiver side of the TypeTester.ZStream client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() bool
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// TypeTesterZStreamClientCall represents the call returned from TypeTester.ZStream.
type TypeTesterZStreamClientCall interface {
	TypeTesterZStreamClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implTypeTesterZStreamClientCall struct {
	rpc.ClientCall
	valRecv bool
	errRecv error
}

func (c *implTypeTesterZStreamClientCall) RecvStream() interface {
	Advance() bool
	Value() bool
	Err() error
} {
	return implTypeTesterZStreamClientCallRecv{c}
}

type implTypeTesterZStreamClientCallRecv struct {
	c *implTypeTesterZStreamClientCall
}

func (c implTypeTesterZStreamClientCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implTypeTesterZStreamClientCallRecv) Value() bool {
	return c.c.valRecv
}
func (c implTypeTesterZStreamClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implTypeTesterZStreamClientCall) Finish() (err error) {
	err = c.ClientCall.Finish()
	return
}

// TypeTesterServerMethods is the interface a server writer
// implements for TypeTester.
//
// TypeTester methods are listed in alphabetical order, to make it easier to
// test Signature output, which sorts methods alphabetically.
type TypeTesterServerMethods interface {
	// Methods to test support for primitive types.
	EchoBool(call rpc.ServerCall, I1 bool) (O1 bool, err error)
	EchoFloat32(call rpc.ServerCall, I1 float32) (O1 float32, err error)
	EchoFloat64(call rpc.ServerCall, I1 float64) (O1 float64, err error)
	EchoInt32(call rpc.ServerCall, I1 int32) (O1 int32, err error)
	EchoInt64(call rpc.ServerCall, I1 int64) (O1 int64, err error)
	EchoString(call rpc.ServerCall, I1 string) (O1 string, err error)
	EchoByte(call rpc.ServerCall, I1 byte) (O1 byte, err error)
	EchoUint32(call rpc.ServerCall, I1 uint32) (O1 uint32, err error)
	EchoUint64(call rpc.ServerCall, I1 uint64) (O1 uint64, err error)
	// Methods to test support for composite types.
	XEchoArray(call rpc.ServerCall, I1 Array2Int) (O1 Array2Int, err error)
	XEchoMap(call rpc.ServerCall, I1 map[int32]string) (O1 map[int32]string, err error)
	XEchoSet(call rpc.ServerCall, I1 map[int32]struct{}) (O1 map[int32]struct{}, err error)
	XEchoSlice(call rpc.ServerCall, I1 []int32) (O1 []int32, err error)
	XEchoStruct(call rpc.ServerCall, I1 Struct) (O1 Struct, err error)
	// Methods to test support for different number of arguments.
	YMultiArg(call rpc.ServerCall, I1 int32, I2 int32) (O1 int32, O2 int32, err error)
	YNoArgs(rpc.ServerCall) error
	// Methods to test support for streaming.
	ZStream(call TypeTesterZStreamServerCall, NumStreamItems int32, StreamItem bool) error
}

// TypeTesterServerStubMethods is the server interface containing
// TypeTester methods, as expected by rpc.Server.
// The only difference between this interface and TypeTesterServerMethods
// is the streaming methods.
type TypeTesterServerStubMethods interface {
	// Methods to test support for primitive types.
	EchoBool(call rpc.ServerCall, I1 bool) (O1 bool, err error)
	EchoFloat32(call rpc.ServerCall, I1 float32) (O1 float32, err error)
	EchoFloat64(call rpc.ServerCall, I1 float64) (O1 float64, err error)
	EchoInt32(call rpc.ServerCall, I1 int32) (O1 int32, err error)
	EchoInt64(call rpc.ServerCall, I1 int64) (O1 int64, err error)
	EchoString(call rpc.ServerCall, I1 string) (O1 string, err error)
	EchoByte(call rpc.ServerCall, I1 byte) (O1 byte, err error)
	EchoUint32(call rpc.ServerCall, I1 uint32) (O1 uint32, err error)
	EchoUint64(call rpc.ServerCall, I1 uint64) (O1 uint64, err error)
	// Methods to test support for composite types.
	XEchoArray(call rpc.ServerCall, I1 Array2Int) (O1 Array2Int, err error)
	XEchoMap(call rpc.ServerCall, I1 map[int32]string) (O1 map[int32]string, err error)
	XEchoSet(call rpc.ServerCall, I1 map[int32]struct{}) (O1 map[int32]struct{}, err error)
	XEchoSlice(call rpc.ServerCall, I1 []int32) (O1 []int32, err error)
	XEchoStruct(call rpc.ServerCall, I1 Struct) (O1 Struct, err error)
	// Methods to test support for different number of arguments.
	YMultiArg(call rpc.ServerCall, I1 int32, I2 int32) (O1 int32, O2 int32, err error)
	YNoArgs(rpc.ServerCall) error
	// Methods to test support for streaming.
	ZStream(call *TypeTesterZStreamServerCallStub, NumStreamItems int32, StreamItem bool) error
}

// TypeTesterServerStub adds universal methods to TypeTesterServerStubMethods.
type TypeTesterServerStub interface {
	TypeTesterServerStubMethods
	// Describe the TypeTester interfaces.
	Describe__() []rpc.InterfaceDesc
}

// TypeTesterServer returns a server stub for TypeTester.
// It converts an implementation of TypeTesterServerMethods into
// an object that may be used by rpc.Server.
func TypeTesterServer(impl TypeTesterServerMethods) TypeTesterServerStub {
	stub := implTypeTesterServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implTypeTesterServerStub struct {
	impl TypeTesterServerMethods
	gs   *rpc.GlobState
}

func (s implTypeTesterServerStub) EchoBool(call rpc.ServerCall, i0 bool) (bool, error) {
	return s.impl.EchoBool(call, i0)
}

func (s implTypeTesterServerStub) EchoFloat32(call rpc.ServerCall, i0 float32) (float32, error) {
	return s.impl.EchoFloat32(call, i0)
}

func (s implTypeTesterServerStub) EchoFloat64(call rpc.ServerCall, i0 float64) (float64, error) {
	return s.impl.EchoFloat64(call, i0)
}

func (s implTypeTesterServerStub) EchoInt32(call rpc.ServerCall, i0 int32) (int32, error) {
	return s.impl.EchoInt32(call, i0)
}

func (s implTypeTesterServerStub) EchoInt64(call rpc.ServerCall, i0 int64) (int64, error) {
	return s.impl.EchoInt64(call, i0)
}

func (s implTypeTesterServerStub) EchoString(call rpc.ServerCall, i0 string) (string, error) {
	return s.impl.EchoString(call, i0)
}

func (s implTypeTesterServerStub) EchoByte(call rpc.ServerCall, i0 byte) (byte, error) {
	return s.impl.EchoByte(call, i0)
}

func (s implTypeTesterServerStub) EchoUint32(call rpc.ServerCall, i0 uint32) (uint32, error) {
	return s.impl.EchoUint32(call, i0)
}

func (s implTypeTesterServerStub) EchoUint64(call rpc.ServerCall, i0 uint64) (uint64, error) {
	return s.impl.EchoUint64(call, i0)
}

func (s implTypeTesterServerStub) XEchoArray(call rpc.ServerCall, i0 Array2Int) (Array2Int, error) {
	return s.impl.XEchoArray(call, i0)
}

func (s implTypeTesterServerStub) XEchoMap(call rpc.ServerCall, i0 map[int32]string) (map[int32]string, error) {
	return s.impl.XEchoMap(call, i0)
}

func (s implTypeTesterServerStub) XEchoSet(call rpc.ServerCall, i0 map[int32]struct{}) (map[int32]struct{}, error) {
	return s.impl.XEchoSet(call, i0)
}

func (s implTypeTesterServerStub) XEchoSlice(call rpc.ServerCall, i0 []int32) ([]int32, error) {
	return s.impl.XEchoSlice(call, i0)
}

func (s implTypeTesterServerStub) XEchoStruct(call rpc.ServerCall, i0 Struct) (Struct, error) {
	return s.impl.XEchoStruct(call, i0)
}

func (s implTypeTesterServerStub) YMultiArg(call rpc.ServerCall, i0 int32, i1 int32) (int32, int32, error) {
	return s.impl.YMultiArg(call, i0, i1)
}

func (s implTypeTesterServerStub) YNoArgs(call rpc.ServerCall) error {
	return s.impl.YNoArgs(call)
}

func (s implTypeTesterServerStub) ZStream(call *TypeTesterZStreamServerCallStub, i0 int32, i1 bool) error {
	return s.impl.ZStream(call, i0, i1)
}

func (s implTypeTesterServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implTypeTesterServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{TypeTesterDesc}
}

// TypeTesterDesc describes the TypeTester interface.
var TypeTesterDesc rpc.InterfaceDesc = descTypeTester

// descTypeTester hides the desc to keep godoc clean.
var descTypeTester = rpc.InterfaceDesc{
	Name:    "TypeTester",
	PkgPath: "v.io/x/ref/cmd/vrpc/test_base",
	Doc:     "// TypeTester methods are listed in alphabetical order, to make it easier to\n// test Signature output, which sorts methods alphabetically.",
	Methods: []rpc.MethodDesc{
		{
			Name: "EchoBool",
			Doc:  "// Methods to test support for primitive types.",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // bool
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // bool
			},
		},
		{
			Name: "EchoFloat32",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // float32
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // float32
			},
		},
		{
			Name: "EchoFloat64",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // float64
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // float64
			},
		},
		{
			Name: "EchoInt32",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // int32
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // int32
			},
		},
		{
			Name: "EchoInt64",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // int64
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // int64
			},
		},
		{
			Name: "EchoString",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // string
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // string
			},
		},
		{
			Name: "EchoByte",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // byte
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // byte
			},
		},
		{
			Name: "EchoUint32",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // uint32
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // uint32
			},
		},
		{
			Name: "EchoUint64",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // uint64
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // uint64
			},
		},
		{
			Name: "XEchoArray",
			Doc:  "// Methods to test support for composite types.",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // Array2Int
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // Array2Int
			},
		},
		{
			Name: "XEchoMap",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // map[int32]string
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // map[int32]string
			},
		},
		{
			Name: "XEchoSet",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // map[int32]struct{}
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // map[int32]struct{}
			},
		},
		{
			Name: "XEchoSlice",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // []int32
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // []int32
			},
		},
		{
			Name: "XEchoStruct",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // Struct
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // Struct
			},
		},
		{
			Name: "YMultiArg",
			Doc:  "// Methods to test support for different number of arguments.",
			InArgs: []rpc.ArgDesc{
				{"I1", ``}, // int32
				{"I2", ``}, // int32
			},
			OutArgs: []rpc.ArgDesc{
				{"O1", ``}, // int32
				{"O2", ``}, // int32
			},
		},
		{
			Name: "YNoArgs",
		},
		{
			Name: "ZStream",
			Doc:  "// Methods to test support for streaming.",
			InArgs: []rpc.ArgDesc{
				{"NumStreamItems", ``}, // int32
				{"StreamItem", ``},     // bool
			},
		},
	},
}

// TypeTesterZStreamServerStream is the server stream for TypeTester.ZStream.
type TypeTesterZStreamServerStream interface {
	// SendStream returns the send side of the TypeTester.ZStream server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item bool) error
	}
}

// TypeTesterZStreamServerCall represents the context passed to TypeTester.ZStream.
type TypeTesterZStreamServerCall interface {
	rpc.ServerCall
	TypeTesterZStreamServerStream
}

// TypeTesterZStreamServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements TypeTesterZStreamServerCall.
type TypeTesterZStreamServerCallStub struct {
	rpc.StreamServerCall
}

// Init initializes TypeTesterZStreamServerCallStub from rpc.StreamServerCall.
func (s *TypeTesterZStreamServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// SendStream returns the send side of the TypeTester.ZStream server stream.
func (s *TypeTesterZStreamServerCallStub) SendStream() interface {
	Send(item bool) error
} {
	return implTypeTesterZStreamServerCallSend{s}
}

type implTypeTesterZStreamServerCallSend struct {
	s *TypeTesterZStreamServerCallStub
}

func (s implTypeTesterZStreamServerCallSend) Send(item bool) error {
	return s.s.Send(item)
}
