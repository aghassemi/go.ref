// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Source: raft.vdl

package raft

import (
	// VDL system imports
	"io"
	"v.io/v23"
	"v.io/v23/context"
	"v.io/v23/rpc"
	"v.io/v23/vdl"
)

// Basic types used throughout raft.
type Term uint64

func (Term) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/raft.Term"`
}) {
}

type Index uint64

func (Index) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/raft.Index"`
}) {
}

type LogEntry struct {
	Term  Term
	Index Index
	Cmd   []byte
	Error error
}

func (LogEntry) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/raft.LogEntry"`
}) {
}

func init() {
	vdl.Register((*Term)(nil))
	vdl.Register((*Index)(nil))
	vdl.Register((*LogEntry)(nil))
}

// raftProtoClientMethods is the client interface
// containing raftProto methods.
//
// raftProto is used by the members of a raft set to communicate with each other.
type raftProtoClientMethods interface {
	// Members returns the current set of raft members.
	Members(*context.T, ...rpc.CallOpt) ([]string, error)
	// Leader returns the current leader server.
	Leader(*context.T, ...rpc.CallOpt) (string, error)
	// RequestVote starts a new round of voting.  It returns the server's current Term and true if
	// the server voted for the client.
	RequestVote(_ *context.T, term Term, candidate string, lastLogTerm Term, lastLogIndex Index, _ ...rpc.CallOpt) (Term Term, Granted bool, _ error)
	// AppendToLog is sent by the leader to tell followers to append an entry.  If cmds
	// is empty, this is a keep alive message (at a random interval after a keep alive, followers
	// will initiate a new round of voting).
	AppendToLog(_ *context.T, term Term, leader string, prevIndex Index, prevTerm Term, leaderCommit Index, cmds []LogEntry, _ ...rpc.CallOpt) error
	// Append is sent only to the leader.  First error is the client error when applying the command.  The second is
	// the result of trying to log the command.
	Append(_ *context.T, cmd []byte, _ ...rpc.CallOpt) (error, error)
	// InstallSnapshot installs the given snapshot and restarts server.
	InstallSnapshot(_ *context.T, term Term, leader string, appliedTerm Term, appliedIndex Index, _ ...rpc.CallOpt) (raftProtoInstallSnapshotClientCall, error)
}

// raftProtoClientStub adds universal methods to raftProtoClientMethods.
type raftProtoClientStub interface {
	raftProtoClientMethods
	rpc.UniversalServiceMethods
}

// raftProtoClient returns a client stub for raftProto.
func raftProtoClient(name string) raftProtoClientStub {
	return implraftProtoClientStub{name}
}

type implraftProtoClientStub struct {
	name string
}

func (c implraftProtoClientStub) Members(ctx *context.T, opts ...rpc.CallOpt) (o0 []string, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Members", nil, []interface{}{&o0}, opts...)
	return
}

func (c implraftProtoClientStub) Leader(ctx *context.T, opts ...rpc.CallOpt) (o0 string, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Leader", nil, []interface{}{&o0}, opts...)
	return
}

func (c implraftProtoClientStub) RequestVote(ctx *context.T, i0 Term, i1 string, i2 Term, i3 Index, opts ...rpc.CallOpt) (o0 Term, o1 bool, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "RequestVote", []interface{}{i0, i1, i2, i3}, []interface{}{&o0, &o1}, opts...)
	return
}

func (c implraftProtoClientStub) AppendToLog(ctx *context.T, i0 Term, i1 string, i2 Index, i3 Term, i4 Index, i5 []LogEntry, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "AppendToLog", []interface{}{i0, i1, i2, i3, i4, i5}, nil, opts...)
	return
}

func (c implraftProtoClientStub) Append(ctx *context.T, i0 []byte, opts ...rpc.CallOpt) (o0 error, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Append", []interface{}{i0}, []interface{}{&o0}, opts...)
	return
}

func (c implraftProtoClientStub) InstallSnapshot(ctx *context.T, i0 Term, i1 string, i2 Term, i3 Index, opts ...rpc.CallOpt) (ocall raftProtoInstallSnapshotClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "InstallSnapshot", []interface{}{i0, i1, i2, i3}, opts...); err != nil {
		return
	}
	ocall = &implraftProtoInstallSnapshotClientCall{ClientCall: call}
	return
}

// raftProtoInstallSnapshotClientStream is the client stream for raftProto.InstallSnapshot.
type raftProtoInstallSnapshotClientStream interface {
	// SendStream returns the send side of the raftProto.InstallSnapshot client stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors
		// encountered while sending, or if Send is called after Close or
		// the stream has been canceled.  Blocks if there is no buffer
		// space; will unblock when buffer space is available or after
		// the stream has been canceled.
		Send(item []byte) error
		// Close indicates to the server that no more items will be sent;
		// server Recv calls will receive io.EOF after all sent items.
		// This is an optional call - e.g. a client might call Close if it
		// needs to continue receiving items from the server after it's
		// done sending.  Returns errors encountered while closing, or if
		// Close is called after the stream has been canceled.  Like Send,
		// blocks if there is no buffer space available.
		Close() error
	}
}

// raftProtoInstallSnapshotClientCall represents the call returned from raftProto.InstallSnapshot.
type raftProtoInstallSnapshotClientCall interface {
	raftProtoInstallSnapshotClientStream
	// Finish performs the equivalent of SendStream().Close, then blocks until
	// the server is done, and returns the positional return values for the call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implraftProtoInstallSnapshotClientCall struct {
	rpc.ClientCall
}

func (c *implraftProtoInstallSnapshotClientCall) SendStream() interface {
	Send(item []byte) error
	Close() error
} {
	return implraftProtoInstallSnapshotClientCallSend{c}
}

type implraftProtoInstallSnapshotClientCallSend struct {
	c *implraftProtoInstallSnapshotClientCall
}

func (c implraftProtoInstallSnapshotClientCallSend) Send(item []byte) error {
	return c.c.Send(item)
}
func (c implraftProtoInstallSnapshotClientCallSend) Close() error {
	return c.c.CloseSend()
}
func (c *implraftProtoInstallSnapshotClientCall) Finish() (err error) {
	err = c.ClientCall.Finish()
	return
}

// raftProtoServerMethods is the interface a server writer
// implements for raftProto.
//
// raftProto is used by the members of a raft set to communicate with each other.
type raftProtoServerMethods interface {
	// Members returns the current set of raft members.
	Members(*context.T, rpc.ServerCall) ([]string, error)
	// Leader returns the current leader server.
	Leader(*context.T, rpc.ServerCall) (string, error)
	// RequestVote starts a new round of voting.  It returns the server's current Term and true if
	// the server voted for the client.
	RequestVote(_ *context.T, _ rpc.ServerCall, term Term, candidate string, lastLogTerm Term, lastLogIndex Index) (Term Term, Granted bool, _ error)
	// AppendToLog is sent by the leader to tell followers to append an entry.  If cmds
	// is empty, this is a keep alive message (at a random interval after a keep alive, followers
	// will initiate a new round of voting).
	AppendToLog(_ *context.T, _ rpc.ServerCall, term Term, leader string, prevIndex Index, prevTerm Term, leaderCommit Index, cmds []LogEntry) error
	// Append is sent only to the leader.  First error is the client error when applying the command.  The second is
	// the result of trying to log the command.
	Append(_ *context.T, _ rpc.ServerCall, cmd []byte) (error, error)
	// InstallSnapshot installs the given snapshot and restarts server.
	InstallSnapshot(_ *context.T, _ raftProtoInstallSnapshotServerCall, term Term, leader string, appliedTerm Term, appliedIndex Index) error
}

// raftProtoServerStubMethods is the server interface containing
// raftProto methods, as expected by rpc.Server.
// The only difference between this interface and raftProtoServerMethods
// is the streaming methods.
type raftProtoServerStubMethods interface {
	// Members returns the current set of raft members.
	Members(*context.T, rpc.ServerCall) ([]string, error)
	// Leader returns the current leader server.
	Leader(*context.T, rpc.ServerCall) (string, error)
	// RequestVote starts a new round of voting.  It returns the server's current Term and true if
	// the server voted for the client.
	RequestVote(_ *context.T, _ rpc.ServerCall, term Term, candidate string, lastLogTerm Term, lastLogIndex Index) (Term Term, Granted bool, _ error)
	// AppendToLog is sent by the leader to tell followers to append an entry.  If cmds
	// is empty, this is a keep alive message (at a random interval after a keep alive, followers
	// will initiate a new round of voting).
	AppendToLog(_ *context.T, _ rpc.ServerCall, term Term, leader string, prevIndex Index, prevTerm Term, leaderCommit Index, cmds []LogEntry) error
	// Append is sent only to the leader.  First error is the client error when applying the command.  The second is
	// the result of trying to log the command.
	Append(_ *context.T, _ rpc.ServerCall, cmd []byte) (error, error)
	// InstallSnapshot installs the given snapshot and restarts server.
	InstallSnapshot(_ *context.T, _ *raftProtoInstallSnapshotServerCallStub, term Term, leader string, appliedTerm Term, appliedIndex Index) error
}

// raftProtoServerStub adds universal methods to raftProtoServerStubMethods.
type raftProtoServerStub interface {
	raftProtoServerStubMethods
	// Describe the raftProto interfaces.
	Describe__() []rpc.InterfaceDesc
}

// raftProtoServer returns a server stub for raftProto.
// It converts an implementation of raftProtoServerMethods into
// an object that may be used by rpc.Server.
func raftProtoServer(impl raftProtoServerMethods) raftProtoServerStub {
	stub := implraftProtoServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implraftProtoServerStub struct {
	impl raftProtoServerMethods
	gs   *rpc.GlobState
}

func (s implraftProtoServerStub) Members(ctx *context.T, call rpc.ServerCall) ([]string, error) {
	return s.impl.Members(ctx, call)
}

func (s implraftProtoServerStub) Leader(ctx *context.T, call rpc.ServerCall) (string, error) {
	return s.impl.Leader(ctx, call)
}

func (s implraftProtoServerStub) RequestVote(ctx *context.T, call rpc.ServerCall, i0 Term, i1 string, i2 Term, i3 Index) (Term, bool, error) {
	return s.impl.RequestVote(ctx, call, i0, i1, i2, i3)
}

func (s implraftProtoServerStub) AppendToLog(ctx *context.T, call rpc.ServerCall, i0 Term, i1 string, i2 Index, i3 Term, i4 Index, i5 []LogEntry) error {
	return s.impl.AppendToLog(ctx, call, i0, i1, i2, i3, i4, i5)
}

func (s implraftProtoServerStub) Append(ctx *context.T, call rpc.ServerCall, i0 []byte) (error, error) {
	return s.impl.Append(ctx, call, i0)
}

func (s implraftProtoServerStub) InstallSnapshot(ctx *context.T, call *raftProtoInstallSnapshotServerCallStub, i0 Term, i1 string, i2 Term, i3 Index) error {
	return s.impl.InstallSnapshot(ctx, call, i0, i1, i2, i3)
}

func (s implraftProtoServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implraftProtoServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{raftProtoDesc}
}

// raftProtoDesc describes the raftProto interface.
var raftProtoDesc rpc.InterfaceDesc = descraftProto

// descraftProto hides the desc to keep godoc clean.
var descraftProto = rpc.InterfaceDesc{
	Name:    "raftProto",
	PkgPath: "v.io/x/ref/lib/raft",
	Doc:     "// raftProto is used by the members of a raft set to communicate with each other.",
	Methods: []rpc.MethodDesc{
		{
			Name: "Members",
			Doc:  "// Members returns the current set of raft members.",
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // []string
			},
		},
		{
			Name: "Leader",
			Doc:  "// Leader returns the current leader server.",
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // string
			},
		},
		{
			Name: "RequestVote",
			Doc:  "// RequestVote starts a new round of voting.  It returns the server's current Term and true if\n// the server voted for the client.",
			InArgs: []rpc.ArgDesc{
				{"term", ``},         // Term
				{"candidate", ``},    // string
				{"lastLogTerm", ``},  // Term
				{"lastLogIndex", ``}, // Index
			},
			OutArgs: []rpc.ArgDesc{
				{"Term", ``},    // Term
				{"Granted", ``}, // bool
			},
		},
		{
			Name: "AppendToLog",
			Doc:  "// AppendToLog is sent by the leader to tell followers to append an entry.  If cmds\n// is empty, this is a keep alive message (at a random interval after a keep alive, followers\n// will initiate a new round of voting).",
			InArgs: []rpc.ArgDesc{
				{"term", ``},         // Term
				{"leader", ``},       // string
				{"prevIndex", ``},    // Index
				{"prevTerm", ``},     // Term
				{"leaderCommit", ``}, // Index
				{"cmds", ``},         // []LogEntry
			},
		},
		{
			Name: "Append",
			Doc:  "// Append is sent only to the leader.  First error is the client error when applying the command.  The second is\n// the result of trying to log the command.",
			InArgs: []rpc.ArgDesc{
				{"cmd", ``}, // []byte
			},
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // error
			},
		},
		{
			Name: "InstallSnapshot",
			Doc:  "// InstallSnapshot installs the given snapshot and restarts server.",
			InArgs: []rpc.ArgDesc{
				{"term", ``},         // Term
				{"leader", ``},       // string
				{"appliedTerm", ``},  // Term
				{"appliedIndex", ``}, // Index
			},
		},
	},
}

// raftProtoInstallSnapshotServerStream is the server stream for raftProto.InstallSnapshot.
type raftProtoInstallSnapshotServerStream interface {
	// RecvStream returns the receiver side of the raftProto.InstallSnapshot server stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() []byte
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// raftProtoInstallSnapshotServerCall represents the context passed to raftProto.InstallSnapshot.
type raftProtoInstallSnapshotServerCall interface {
	rpc.ServerCall
	raftProtoInstallSnapshotServerStream
}

// raftProtoInstallSnapshotServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements raftProtoInstallSnapshotServerCall.
type raftProtoInstallSnapshotServerCallStub struct {
	rpc.StreamServerCall
	valRecv []byte
	errRecv error
}

// Init initializes raftProtoInstallSnapshotServerCallStub from rpc.StreamServerCall.
func (s *raftProtoInstallSnapshotServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// RecvStream returns the receiver side of the raftProto.InstallSnapshot server stream.
func (s *raftProtoInstallSnapshotServerCallStub) RecvStream() interface {
	Advance() bool
	Value() []byte
	Err() error
} {
	return implraftProtoInstallSnapshotServerCallRecv{s}
}

type implraftProtoInstallSnapshotServerCallRecv struct {
	s *raftProtoInstallSnapshotServerCallStub
}

func (s implraftProtoInstallSnapshotServerCallRecv) Advance() bool {
	s.s.errRecv = s.s.Recv(&s.s.valRecv)
	return s.s.errRecv == nil
}
func (s implraftProtoInstallSnapshotServerCallRecv) Value() []byte {
	return s.s.valRecv
}
func (s implraftProtoInstallSnapshotServerCallRecv) Err() error {
	if s.s.errRecv == io.EOF {
		return nil
	}
	return s.s.errRecv
}
