// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Source: types.vdl

package discovery

import (
	// VDL system imports
	"v.io/v23/vdl"

	// VDL user imports
	"v.io/v23/discovery"
)

type EncryptionAlgorithm int32

func (EncryptionAlgorithm) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/discovery.EncryptionAlgorithm"`
}) {
}

func (m EncryptionAlgorithm) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64(m), __VDLType_types_v_io_x_ref_lib_discovery_EncryptionAlgorithm); err != nil {
		return err
	}
	return nil
}

func (m EncryptionAlgorithm) MakeVDLTarget() vdl.Target {
	return nil
}

type EncryptionKey []byte

func (EncryptionKey) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/discovery.EncryptionKey"`
}) {
}

func (m EncryptionKey) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {

	if err := t.FromBytes([]byte(m), __VDLType_types_v_io_x_ref_lib_discovery_EncryptionKey); err != nil {
		return err
	}
	return nil
}

func (m EncryptionKey) MakeVDLTarget() vdl.Target {
	return nil
}

type Uuid []byte

func (Uuid) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/discovery.Uuid"`
}) {
}

func (m Uuid) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {

	if err := t.FromBytes([]byte(m), __VDLType_types_v_io_x_ref_lib_discovery_Uuid); err != nil {
		return err
	}
	return nil
}

func (m Uuid) MakeVDLTarget() vdl.Target {
	return nil
}

// AdInfo represents advertisement information for discovery.
type AdInfo struct {
	Ad discovery.Advertisement
	// Type of encryption applied to the advertisement so that it can
	// only be decoded by authorized principals.
	EncryptionAlgorithm EncryptionAlgorithm
	// If the advertisement is encrypted, then the data required to
	// decrypt it. The format of this data is a function of the algorithm.
	EncryptionKeys []EncryptionKey
	// Hash of the current advertisement.
	Hash AdHash
	// The addresses (vanadium object names) that the advertisement directory service
	// is served on. See directory.vdl.
	DirAddrs []string
	// TODO(jhahn): Add proximity.
	// TODO(jhahn): Use proximity for Lost.
	Lost bool
}

func (AdInfo) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/discovery.AdInfo"`
}) {
}

func (m *AdInfo) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {

	if __VDLType_types_v_io_x_ref_lib_discovery_AdInfo == nil || __VDLTypetypes0 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Ad")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Ad.FillVDLTarget(fieldTarget3, __VDLType_types_v_io_v23_discovery_Advertisement); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("EncryptionAlgorithm")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.EncryptionAlgorithm.FillVDLTarget(fieldTarget5, __VDLType_types_v_io_x_ref_lib_discovery_EncryptionAlgorithm); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("EncryptionKeys")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget8, err := fieldTarget7.StartList(__VDLTypetypes1, len(m.EncryptionKeys))
		if err != nil {
			return err
		}
		for i, elem10 := range m.EncryptionKeys {
			elemTarget9, err := listTarget8.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem10.FillVDLTarget(elemTarget9, __VDLType_types_v_io_x_ref_lib_discovery_EncryptionKey); err != nil {
				return err
			}
			if err := listTarget8.FinishElem(elemTarget9); err != nil {
				return err
			}
		}
		if err := fieldTarget7.FinishList(listTarget8); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Hash")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Hash.FillVDLTarget(fieldTarget12, __VDLType_types_v_io_x_ref_lib_discovery_AdHash); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("DirAddrs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget15, err := fieldTarget14.StartList(__VDLTypetypes2, len(m.DirAddrs))
		if err != nil {
			return err
		}
		for i, elem17 := range m.DirAddrs {
			elemTarget16, err := listTarget15.StartElem(i)
			if err != nil {
				return err
			}
			if err := elemTarget16.FromString(string(elem17), vdl.StringType); err != nil {
				return err
			}
			if err := listTarget15.FinishElem(elemTarget16); err != nil {
				return err
			}
		}
		if err := fieldTarget14.FinishList(listTarget15); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
			return err
		}
	}
	keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("Lost")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget19.FromBool(bool(m.Lost), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AdInfo) MakeVDLTarget() vdl.Target {
	return nil
}

// An AdHash is a hash of an advertisement.
type AdHash [8]byte

func (AdHash) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/discovery.AdHash"`
}) {
}

func (m AdHash) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {

	if err := t.FromBytes([]byte(m[:]), __VDLType_types_v_io_x_ref_lib_discovery_AdHash); err != nil {
		return err
	}
	return nil
}

func (m AdHash) MakeVDLTarget() vdl.Target {
	return nil
}

func init() {
	vdl.Register((*EncryptionAlgorithm)(nil))
	vdl.Register((*EncryptionKey)(nil))
	vdl.Register((*Uuid)(nil))
	vdl.Register((*AdInfo)(nil))
	vdl.Register((*AdHash)(nil))
}

var __VDLTypetypes0 *vdl.Type = vdl.TypeOf((*AdInfo)(nil))
var __VDLTypetypes2 *vdl.Type = vdl.TypeOf([]string(nil))
var __VDLTypetypes1 *vdl.Type = vdl.TypeOf([]EncryptionKey(nil))
var __VDLType_types_v_io_v23_discovery_Advertisement *vdl.Type = vdl.TypeOf(discovery.Advertisement{})
var __VDLType_types_v_io_x_ref_lib_discovery_AdHash *vdl.Type = vdl.TypeOf(AdHash{})
var __VDLType_types_v_io_x_ref_lib_discovery_AdInfo *vdl.Type = vdl.TypeOf(AdInfo{})
var __VDLType_types_v_io_x_ref_lib_discovery_EncryptionAlgorithm *vdl.Type = vdl.TypeOf(EncryptionAlgorithm(0))
var __VDLType_types_v_io_x_ref_lib_discovery_EncryptionKey *vdl.Type = vdl.TypeOf(EncryptionKey(nil))
var __VDLType_types_v_io_x_ref_lib_discovery_Uuid *vdl.Type = vdl.TypeOf(Uuid(nil))

func __VDLEnsureNativeBuilt_types() {
}

const NoEncryption = EncryptionAlgorithm(0)

const TestEncryption = EncryptionAlgorithm(1)

const IbeEncryption = EncryptionAlgorithm(2)
