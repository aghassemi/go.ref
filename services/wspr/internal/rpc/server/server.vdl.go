// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: server

package server

import (
	"fmt"
	"reflect"
	"v.io/v23/context"
	"v.io/v23/i18n"
	"v.io/v23/security"
	"v.io/v23/vdl"
	"v.io/v23/vdlroot/signature"
	"v.io/v23/vdlroot/time"
	"v.io/v23/verror"
	"v.io/v23/vom"
	"v.io/v23/vtrace"
	"v.io/x/ref/services/wspr/internal/principal"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

type Context struct {
	Language string
}

func (Context) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.Context"`
}) {
}

func (m *Context) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Language")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Language), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Context) MakeVDLTarget() vdl.Target {
	return &ContextTarget{Value: m}
}

type ContextTarget struct {
	Value          *Context
	languageTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ContextTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Context)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ContextTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Language":
		t.languageTarget.Value = &t.Value.Language
		target, err := &t.languageTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.Context", name)
	}
}
func (t *ContextTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ContextTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type SecurityCall struct {
	Method                string
	Suffix                string
	MethodTags            []*vom.RawBytes
	LocalBlessings        principal.BlessingsId
	LocalBlessingStrings  []string
	RemoteBlessings       principal.BlessingsId
	RemoteBlessingStrings []string
	LocalEndpoint         string
	RemoteEndpoint        string
}

func (SecurityCall) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.SecurityCall"`
}) {
}

func (m *SecurityCall) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Method")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Method), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Suffix")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.Suffix), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("MethodTags")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget8, err := fieldTarget7.StartList(tt.NonOptional().Field(2).Type, len(m.MethodTags))
		if err != nil {
			return err
		}
		for i, elem10 := range m.MethodTags {
			elemTarget9, err := listTarget8.StartElem(i)
			if err != nil {
				return err
			}

			if elem10 == nil {
				if err := elemTarget9.FromNil(tt.NonOptional().Field(2).Type.Elem()); err != nil {
					return err
				}
			} else {
				if err := elem10.FillVDLTarget(elemTarget9, tt.NonOptional().Field(2).Type.Elem()); err != nil {
					return err
				}
			}
			if err := listTarget8.FinishElem(elemTarget9); err != nil {
				return err
			}
		}
		if err := fieldTarget7.FinishList(listTarget8); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("LocalBlessings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.LocalBlessings.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("LocalBlessingStrings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget15, err := fieldTarget14.StartList(tt.NonOptional().Field(4).Type, len(m.LocalBlessingStrings))
		if err != nil {
			return err
		}
		for i, elem17 := range m.LocalBlessingStrings {
			elemTarget16, err := listTarget15.StartElem(i)
			if err != nil {
				return err
			}
			if err := elemTarget16.FromString(string(elem17), tt.NonOptional().Field(4).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget15.FinishElem(elemTarget16); err != nil {
				return err
			}
		}
		if err := fieldTarget14.FinishList(listTarget15); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
			return err
		}
	}
	keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("RemoteBlessings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.RemoteBlessings.FillVDLTarget(fieldTarget19, tt.NonOptional().Field(5).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
			return err
		}
	}
	keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("RemoteBlessingStrings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget22, err := fieldTarget21.StartList(tt.NonOptional().Field(6).Type, len(m.RemoteBlessingStrings))
		if err != nil {
			return err
		}
		for i, elem24 := range m.RemoteBlessingStrings {
			elemTarget23, err := listTarget22.StartElem(i)
			if err != nil {
				return err
			}
			if err := elemTarget23.FromString(string(elem24), tt.NonOptional().Field(6).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget22.FinishElem(elemTarget23); err != nil {
				return err
			}
		}
		if err := fieldTarget21.FinishList(listTarget22); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
			return err
		}
	}
	keyTarget25, fieldTarget26, err := fieldsTarget1.StartField("LocalEndpoint")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget26.FromString(string(m.LocalEndpoint), tt.NonOptional().Field(7).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget25, fieldTarget26); err != nil {
			return err
		}
	}
	keyTarget27, fieldTarget28, err := fieldsTarget1.StartField("RemoteEndpoint")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget28.FromString(string(m.RemoteEndpoint), tt.NonOptional().Field(8).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget27, fieldTarget28); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SecurityCall) MakeVDLTarget() vdl.Target {
	return &SecurityCallTarget{Value: m}
}

type SecurityCallTarget struct {
	Value                       *SecurityCall
	methodTarget                vdl.StringTarget
	suffixTarget                vdl.StringTarget
	methodTagsTarget            __VDLTarget1_list
	localBlessingsTarget        principal.BlessingsIdTarget
	localBlessingStringsTarget  vdl.StringSliceTarget
	remoteBlessingsTarget       principal.BlessingsIdTarget
	remoteBlessingStringsTarget vdl.StringSliceTarget
	localEndpointTarget         vdl.StringTarget
	remoteEndpointTarget        vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SecurityCallTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*SecurityCall)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *SecurityCallTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Method":
		t.methodTarget.Value = &t.Value.Method
		target, err := &t.methodTarget, error(nil)
		return nil, target, err
	case "Suffix":
		t.suffixTarget.Value = &t.Value.Suffix
		target, err := &t.suffixTarget, error(nil)
		return nil, target, err
	case "MethodTags":
		t.methodTagsTarget.Value = &t.Value.MethodTags
		target, err := &t.methodTagsTarget, error(nil)
		return nil, target, err
	case "LocalBlessings":
		t.localBlessingsTarget.Value = &t.Value.LocalBlessings
		target, err := &t.localBlessingsTarget, error(nil)
		return nil, target, err
	case "LocalBlessingStrings":
		t.localBlessingStringsTarget.Value = &t.Value.LocalBlessingStrings
		target, err := &t.localBlessingStringsTarget, error(nil)
		return nil, target, err
	case "RemoteBlessings":
		t.remoteBlessingsTarget.Value = &t.Value.RemoteBlessings
		target, err := &t.remoteBlessingsTarget, error(nil)
		return nil, target, err
	case "RemoteBlessingStrings":
		t.remoteBlessingStringsTarget.Value = &t.Value.RemoteBlessingStrings
		target, err := &t.remoteBlessingStringsTarget, error(nil)
		return nil, target, err
	case "LocalEndpoint":
		t.localEndpointTarget.Value = &t.Value.LocalEndpoint
		target, err := &t.localEndpointTarget, error(nil)
		return nil, target, err
	case "RemoteEndpoint":
		t.remoteEndpointTarget.Value = &t.Value.RemoteEndpoint
		target, err := &t.remoteEndpointTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.SecurityCall", name)
	}
}
func (t *SecurityCallTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SecurityCallTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []*vom.RawBytes
type __VDLTarget1_list struct {
	Value *[]*vom.RawBytes

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]*vom.RawBytes)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vom.RawBytes, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

type CaveatValidationRequest struct {
	Call    SecurityCall
	Context Context
	Cavs    [][]security.Caveat
}

func (CaveatValidationRequest) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.CaveatValidationRequest"`
}) {
}

func (m *CaveatValidationRequest) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Call")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Call.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Context")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Context.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Cavs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget8, err := fieldTarget7.StartList(tt.NonOptional().Field(2).Type, len(m.Cavs))
		if err != nil {
			return err
		}
		for i, elem10 := range m.Cavs {
			elemTarget9, err := listTarget8.StartElem(i)
			if err != nil {
				return err
			}

			listTarget11, err := elemTarget9.StartList(tt.NonOptional().Field(2).Type.Elem(), len(elem10))
			if err != nil {
				return err
			}
			for i, elem13 := range elem10 {
				elemTarget12, err := listTarget11.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem13.FillVDLTarget(elemTarget12, tt.NonOptional().Field(2).Type.Elem().Elem()); err != nil {
					return err
				}
				if err := listTarget11.FinishElem(elemTarget12); err != nil {
					return err
				}
			}
			if err := elemTarget9.FinishList(listTarget11); err != nil {
				return err
			}
			if err := listTarget8.FinishElem(elemTarget9); err != nil {
				return err
			}
		}
		if err := fieldTarget7.FinishList(listTarget8); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *CaveatValidationRequest) MakeVDLTarget() vdl.Target {
	return &CaveatValidationRequestTarget{Value: m}
}

type CaveatValidationRequestTarget struct {
	Value         *CaveatValidationRequest
	callTarget    SecurityCallTarget
	contextTarget ContextTarget
	cavsTarget    __VDLTarget2_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CaveatValidationRequestTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*CaveatValidationRequest)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CaveatValidationRequestTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Call":
		t.callTarget.Value = &t.Value.Call
		target, err := &t.callTarget, error(nil)
		return nil, target, err
	case "Context":
		t.contextTarget.Value = &t.Value.Context
		target, err := &t.contextTarget, error(nil)
		return nil, target, err
	case "Cavs":
		t.cavsTarget.Value = &t.Value.Cavs
		target, err := &t.cavsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.CaveatValidationRequest", name)
	}
}
func (t *CaveatValidationRequestTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CaveatValidationRequestTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// [][]security.Caveat
type __VDLTarget2_list struct {
	Value      *[][]security.Caveat
	elemTarget __VDLTarget3_list
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget2_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[][]security.Caveat)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([][]security.Caveat, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget2_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget2_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// []security.Caveat
type __VDLTarget3_list struct {
	Value      *[]security.Caveat
	elemTarget security.CaveatTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget3_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]security.Caveat)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]security.Caveat, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget3_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget3_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

type CaveatValidationResponse struct {
	Results []error
}

func (CaveatValidationResponse) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.CaveatValidationResponse"`
}) {
}

func (m *CaveatValidationResponse) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Results")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget4, err := fieldTarget3.StartList(tt.NonOptional().Field(0).Type, len(m.Results))
		if err != nil {
			return err
		}
		for i, elem6 := range m.Results {
			elemTarget5, err := listTarget4.StartElem(i)
			if err != nil {
				return err
			}

			if elem6 == nil {
				if err := elemTarget5.FromNil(tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
			} else {
				var wireError7 vdl.WireError
				if err := verror.WireFromNative(&wireError7, elem6); err != nil {
					return err
				}
				if err := wireError7.FillVDLTarget(elemTarget5, vdl.ErrorType); err != nil {
					return err
				}

			}
			if err := listTarget4.FinishElem(elemTarget5); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishList(listTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *CaveatValidationResponse) MakeVDLTarget() vdl.Target {
	return &CaveatValidationResponseTarget{Value: m}
}

type CaveatValidationResponseTarget struct {
	Value         *CaveatValidationResponse
	resultsTarget __VDLTarget4_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CaveatValidationResponseTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*CaveatValidationResponse)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CaveatValidationResponseTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Results":
		t.resultsTarget.Value = &t.Value.Results
		target, err := &t.resultsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.CaveatValidationResponse", name)
	}
}
func (t *CaveatValidationResponseTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CaveatValidationResponseTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []error
type __VDLTarget4_list struct {
	Value      *[]error
	elemTarget verror.ErrorTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget4_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]error)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]error, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget4_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget4_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

type ServerRpcRequestCall struct {
	SecurityCall     SecurityCall
	Deadline         time.Deadline
	Context          Context
	TraceRequest     vtrace.Request
	GrantedBlessings principal.BlessingsId
}

func (ServerRpcRequestCall) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.ServerRpcRequestCall"`
}) {
}

func (m *ServerRpcRequestCall) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("SecurityCall")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.SecurityCall.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	var wireValue4 time.WireDeadline
	if err := time.WireDeadlineFromNative(&wireValue4, m.Deadline); err != nil {
		return err
	}

	keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Deadline")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue4.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
			return err
		}
	}
	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("Context")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Context.FillVDLTarget(fieldTarget8, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("TraceRequest")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.TraceRequest.FillVDLTarget(fieldTarget10, tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("GrantedBlessings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.GrantedBlessings.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(4).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ServerRpcRequestCall) MakeVDLTarget() vdl.Target {
	return &ServerRpcRequestCallTarget{Value: m}
}

type ServerRpcRequestCallTarget struct {
	Value                  *ServerRpcRequestCall
	securityCallTarget     SecurityCallTarget
	deadlineTarget         time.WireDeadlineTarget
	contextTarget          ContextTarget
	traceRequestTarget     vtrace.RequestTarget
	grantedBlessingsTarget principal.BlessingsIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ServerRpcRequestCallTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ServerRpcRequestCall)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ServerRpcRequestCallTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "SecurityCall":
		t.securityCallTarget.Value = &t.Value.SecurityCall
		target, err := &t.securityCallTarget, error(nil)
		return nil, target, err
	case "Deadline":
		t.deadlineTarget.Value = &t.Value.Deadline
		target, err := &t.deadlineTarget, error(nil)
		return nil, target, err
	case "Context":
		t.contextTarget.Value = &t.Value.Context
		target, err := &t.contextTarget, error(nil)
		return nil, target, err
	case "TraceRequest":
		t.traceRequestTarget.Value = &t.Value.TraceRequest
		target, err := &t.traceRequestTarget, error(nil)
		return nil, target, err
	case "GrantedBlessings":
		t.grantedBlessingsTarget.Value = &t.Value.GrantedBlessings
		target, err := &t.grantedBlessingsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.ServerRpcRequestCall", name)
	}
}
func (t *ServerRpcRequestCallTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ServerRpcRequestCallTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// A request from the proxy to javascript to handle an RPC
type ServerRpcRequest struct {
	ServerId uint32
	Handle   int32
	Method   string
	Args     []*vom.RawBytes
	Call     ServerRpcRequestCall
}

func (ServerRpcRequest) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.ServerRpcRequest"`
}) {
}

func (m *ServerRpcRequest) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ServerId")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromUint(uint64(m.ServerId), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Handle")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromInt(int64(m.Handle), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Method")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromString(string(m.Method), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Args")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget10, err := fieldTarget9.StartList(tt.NonOptional().Field(3).Type, len(m.Args))
		if err != nil {
			return err
		}
		for i, elem12 := range m.Args {
			elemTarget11, err := listTarget10.StartElem(i)
			if err != nil {
				return err
			}

			if elem12 == nil {
				if err := elemTarget11.FromNil(tt.NonOptional().Field(3).Type.Elem()); err != nil {
					return err
				}
			} else {
				if err := elem12.FillVDLTarget(elemTarget11, tt.NonOptional().Field(3).Type.Elem()); err != nil {
					return err
				}
			}
			if err := listTarget10.FinishElem(elemTarget11); err != nil {
				return err
			}
		}
		if err := fieldTarget9.FinishList(listTarget10); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("Call")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Call.FillVDLTarget(fieldTarget14, tt.NonOptional().Field(4).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ServerRpcRequest) MakeVDLTarget() vdl.Target {
	return &ServerRpcRequestTarget{Value: m}
}

type ServerRpcRequestTarget struct {
	Value          *ServerRpcRequest
	serverIdTarget vdl.Uint32Target
	handleTarget   vdl.Int32Target
	methodTarget   vdl.StringTarget
	argsTarget     __VDLTarget1_list
	callTarget     ServerRpcRequestCallTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ServerRpcRequestTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ServerRpcRequest)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ServerRpcRequestTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ServerId":
		t.serverIdTarget.Value = &t.Value.ServerId
		target, err := &t.serverIdTarget, error(nil)
		return nil, target, err
	case "Handle":
		t.handleTarget.Value = &t.Value.Handle
		target, err := &t.handleTarget, error(nil)
		return nil, target, err
	case "Method":
		t.methodTarget.Value = &t.Value.Method
		target, err := &t.methodTarget, error(nil)
		return nil, target, err
	case "Args":
		t.argsTarget.Value = &t.Value.Args
		target, err := &t.argsTarget, error(nil)
		return nil, target, err
	case "Call":
		t.callTarget.Value = &t.Value.Call
		target, err := &t.callTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.ServerRpcRequest", name)
	}
}
func (t *ServerRpcRequestTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ServerRpcRequestTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// A reply from javascript to a lookup request.
type LookupReply struct {
	Handle        int32
	HasAuthorizer bool
	HasGlobber    bool
	Signature     []signature.Interface
	Err           error
}

func (LookupReply) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.LookupReply"`
}) {
}

func (m *LookupReply) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Handle")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromInt(int64(m.Handle), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("HasAuthorizer")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromBool(bool(m.HasAuthorizer), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("HasGlobber")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromBool(bool(m.HasGlobber), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Signature")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget10, err := fieldTarget9.StartList(tt.NonOptional().Field(3).Type, len(m.Signature))
		if err != nil {
			return err
		}
		for i, elem12 := range m.Signature {
			elemTarget11, err := listTarget10.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem12.FillVDLTarget(elemTarget11, tt.NonOptional().Field(3).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget10.FinishElem(elemTarget11); err != nil {
				return err
			}
		}
		if err := fieldTarget9.FinishList(listTarget10); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("Err")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Err == nil {
			if err := fieldTarget14.FromNil(tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
		} else {
			var wireError15 vdl.WireError
			if err := verror.WireFromNative(&wireError15, m.Err); err != nil {
				return err
			}
			if err := wireError15.FillVDLTarget(fieldTarget14, vdl.ErrorType); err != nil {
				return err
			}

		}
		if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LookupReply) MakeVDLTarget() vdl.Target {
	return &LookupReplyTarget{Value: m}
}

type LookupReplyTarget struct {
	Value               *LookupReply
	handleTarget        vdl.Int32Target
	hasAuthorizerTarget vdl.BoolTarget
	hasGlobberTarget    vdl.BoolTarget
	signatureTarget     __VDLTarget5_list
	errTarget           verror.ErrorTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LookupReplyTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LookupReply)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LookupReplyTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Handle":
		t.handleTarget.Value = &t.Value.Handle
		target, err := &t.handleTarget, error(nil)
		return nil, target, err
	case "HasAuthorizer":
		t.hasAuthorizerTarget.Value = &t.Value.HasAuthorizer
		target, err := &t.hasAuthorizerTarget, error(nil)
		return nil, target, err
	case "HasGlobber":
		t.hasGlobberTarget.Value = &t.Value.HasGlobber
		target, err := &t.hasGlobberTarget, error(nil)
		return nil, target, err
	case "Signature":
		t.signatureTarget.Value = &t.Value.Signature
		target, err := &t.signatureTarget, error(nil)
		return nil, target, err
	case "Err":
		t.errTarget.Value = &t.Value.Err
		target, err := &t.errTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.LookupReply", name)
	}
}
func (t *LookupReplyTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LookupReplyTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []signature.Interface
type __VDLTarget5_list struct {
	Value      *[]signature.Interface
	elemTarget signature.InterfaceTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget5_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]signature.Interface)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]signature.Interface, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget5_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget5_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// A reply from javascript to an auth request.
type AuthReply struct {
	Err error
}

func (AuthReply) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/rpc/server.AuthReply"`
}) {
}

func (m *AuthReply) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Err")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Err == nil {
			if err := fieldTarget3.FromNil(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			var wireError4 vdl.WireError
			if err := verror.WireFromNative(&wireError4, m.Err); err != nil {
				return err
			}
			if err := wireError4.FillVDLTarget(fieldTarget3, vdl.ErrorType); err != nil {
				return err
			}

		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AuthReply) MakeVDLTarget() vdl.Target {
	return &AuthReplyTarget{Value: m}
}

type AuthReplyTarget struct {
	Value     *AuthReply
	errTarget verror.ErrorTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AuthReplyTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*AuthReply)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *AuthReplyTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Err":
		t.errTarget.Value = &t.Value.Err
		target, err := &t.errTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/rpc/server.AuthReply", name)
	}
}
func (t *AuthReplyTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AuthReplyTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Create zero values for each type.
var (
	__VDLZeroContext                  = Context{}
	__VDLZeroSecurityCall             = SecurityCall{}
	__VDLZeroCaveatValidationRequest  = CaveatValidationRequest{}
	__VDLZeroCaveatValidationResponse = CaveatValidationResponse{}
	__VDLZeroServerRpcRequestCall     = ServerRpcRequestCall{}
	__VDLZeroServerRpcRequest         = ServerRpcRequest{}
	__VDLZeroLookupReply              = LookupReply{}
	__VDLZeroAuthReply                = AuthReply{}
)

//////////////////////////////////////////////////
// Error definitions
var (
	ErrCaveatValidationTimeout                 = verror.Register("v.io/x/ref/services/wspr/internal/rpc/server.CaveatValidationTimeout", verror.NoRetry, "{1:}{2:} Caveat validation has timed out")
	ErrInvalidValidationResponseFromJavascript = verror.Register("v.io/x/ref/services/wspr/internal/rpc/server.InvalidValidationResponseFromJavascript", verror.NoRetry, "{1:}{2:} Invalid validation response from javascript")
	ErrServerStopped                           = verror.Register("v.io/x/ref/services/wspr/internal/rpc/server.ServerStopped", verror.RetryBackoff, "{1:}{2:} Server has been stopped")
)

// NewErrCaveatValidationTimeout returns an error with the ErrCaveatValidationTimeout ID.
func NewErrCaveatValidationTimeout(ctx *context.T) error {
	return verror.New(ErrCaveatValidationTimeout, ctx)
}

// NewErrInvalidValidationResponseFromJavascript returns an error with the ErrInvalidValidationResponseFromJavascript ID.
func NewErrInvalidValidationResponseFromJavascript(ctx *context.T) error {
	return verror.New(ErrInvalidValidationResponseFromJavascript, ctx)
}

// NewErrServerStopped returns an error with the ErrServerStopped ID.
func NewErrServerStopped(ctx *context.T) error {
	return verror.New(ErrServerStopped, ctx)
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}

	// Register types.
	vdl.Register((*Context)(nil))
	vdl.Register((*SecurityCall)(nil))
	vdl.Register((*CaveatValidationRequest)(nil))
	vdl.Register((*CaveatValidationResponse)(nil))
	vdl.Register((*ServerRpcRequestCall)(nil))
	vdl.Register((*ServerRpcRequest)(nil))
	vdl.Register((*LookupReply)(nil))
	vdl.Register((*AuthReply)(nil))

	// Set error format strings.
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatValidationTimeout.ID), "{1:}{2:} Caveat validation has timed out")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrInvalidValidationResponseFromJavascript.ID), "{1:}{2:} Invalid validation response from javascript")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrServerStopped.ID), "{1:}{2:} Server has been stopped")

	return struct{}{}
}
