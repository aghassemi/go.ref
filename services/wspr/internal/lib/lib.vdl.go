// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: lib

package lib

import (
	"fmt"
	"reflect"
	"v.io/v23/uniqueid"
	"v.io/v23/vdl"
	"v.io/v23/verror"
	"v.io/v23/vom"
	"v.io/v23/vtrace"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// The response from the javascript server to the proxy.
type ServerRpcReply struct {
	Results       []*vom.RawBytes
	Err           error
	TraceResponse vtrace.Response
}

func (ServerRpcReply) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/lib.ServerRpcReply"`
}) {
}

func (m *ServerRpcReply) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.Results) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("Results"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Results")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget5, err := fieldTarget3.StartList(tt.NonOptional().Field(0).Type, len(m.Results))
			if err != nil {
				return err
			}
			for i, elem7 := range m.Results {
				elemTarget6, err := listTarget5.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem7.FillVDLTarget(elemTarget6, tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget5.FinishElem(elemTarget6); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishList(listTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var10 := (m.Err == (error)(nil))
	if var10 {
		if err := fieldsTarget1.ZeroField("Err"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Err")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			var wireError11 vdl.WireError
			if err := verror.WireFromNative(&wireError11, m.Err); err != nil {
				return err
			}
			if err := wireError11.FillVDLTarget(fieldTarget9, vdl.ErrorType); err != nil {
				return err
			}

			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var14 := true
	var15 := (m.TraceResponse.Flags == vtrace.TraceFlags(0))
	var14 = var14 && var15
	var16 := true
	var17 := (m.TraceResponse.Trace.Id == uniqueid.Id{})
	var16 = var16 && var17
	var var18 bool
	if len(m.TraceResponse.Trace.Spans) == 0 {
		var18 = true
	}
	var16 = var16 && var18
	var14 = var14 && var16
	if var14 {
		if err := fieldsTarget1.ZeroField("TraceResponse"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("TraceResponse")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.TraceResponse.FillVDLTarget(fieldTarget13, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ServerRpcReply) MakeVDLTarget() vdl.Target {
	return &ServerRpcReplyTarget{Value: m}
}

type ServerRpcReplyTarget struct {
	Value               *ServerRpcReply
	resultsTarget       __VDLTarget1_list
	errTarget           verror.ErrorTarget
	traceResponseTarget vtrace.ResponseTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ServerRpcReplyTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ServerRpcReply)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ServerRpcReplyTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Results":
		t.resultsTarget.Value = &t.Value.Results
		target, err := &t.resultsTarget, error(nil)
		return nil, target, err
	case "Err":
		t.errTarget.Value = &t.Value.Err
		target, err := &t.errTarget, error(nil)
		return nil, target, err
	case "TraceResponse":
		t.traceResponseTarget.Value = &t.Value.TraceResponse
		target, err := &t.traceResponseTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/lib.ServerRpcReply", name)
	}
}
func (t *ServerRpcReplyTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ServerRpcReplyTarget) ZeroField(name string) error {
	switch name {
	case "Results":
		t.Value.Results = []*vom.RawBytes(nil)
		return nil
	case "Err":
		t.Value.Err = (error)(nil)
		return nil
	case "TraceResponse":
		t.Value.TraceResponse = vtrace.Response{}
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/lib.ServerRpcReply", name)
	}
}
func (t *ServerRpcReplyTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []*vom.RawBytes
type __VDLTarget1_list struct {
	Value *[]*vom.RawBytes

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]*vom.RawBytes)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vom.RawBytes, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

type LogLevel int

const (
	LogLevelInfo LogLevel = iota
	LogLevelError
)

// LogLevelAll holds all labels for LogLevel.
var LogLevelAll = [...]LogLevel{LogLevelInfo, LogLevelError}

// LogLevelFromString creates a LogLevel from a string label.
func LogLevelFromString(label string) (x LogLevel, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *LogLevel) Set(label string) error {
	switch label {
	case "Info", "info":
		*x = LogLevelInfo
		return nil
	case "Error", "error":
		*x = LogLevelError
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in lib.LogLevel", label)
}

// String returns the string label of x.
func (x LogLevel) String() string {
	switch x {
	case LogLevelInfo:
		return "Info"
	case LogLevelError:
		return "Error"
	}
	return ""
}

func (LogLevel) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/lib.LogLevel"`
	Enum struct{ Info, Error string }
}) {
}

func (m *LogLevel) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *LogLevel) MakeVDLTarget() vdl.Target {
	return &LogLevelTarget{Value: m}
}

type LogLevelTarget struct {
	Value *LogLevel
	vdl.TargetBase
}

func (t *LogLevelTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*LogLevel)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Info":
		*t.Value = 0
	case "Error":
		*t.Value = 1
	default:
		return fmt.Errorf("label %s not in enum LogLevel", src)
	}

	return nil
}

type LogMessage struct {
	Level   LogLevel
	Message string
}

func (LogMessage) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/wspr/internal/lib.LogMessage"`
}) {
}

func (m *LogMessage) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Level == LogLevelInfo)
	if var4 {
		if err := fieldsTarget1.ZeroField("Level"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Level")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Level.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Message == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("Message"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Message")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.Message), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LogMessage) MakeVDLTarget() vdl.Target {
	return &LogMessageTarget{Value: m}
}

type LogMessageTarget struct {
	Value         *LogMessage
	levelTarget   LogLevelTarget
	messageTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LogMessageTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LogMessage)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LogMessageTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Level":
		t.levelTarget.Value = &t.Value.Level
		target, err := &t.levelTarget, error(nil)
		return nil, target, err
	case "Message":
		t.messageTarget.Value = &t.Value.Message
		target, err := &t.messageTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/lib.LogMessage", name)
	}
}
func (t *LogMessageTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LogMessageTarget) ZeroField(name string) error {
	switch name {
	case "Level":
		t.Value.Level = LogLevelInfo
		return nil
	case "Message":
		t.Value.Message = ""
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/wspr/internal/lib.LogMessage", name)
	}
}
func (t *LogMessageTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*ServerRpcReply)(nil))
	vdl.Register((*LogLevel)(nil))
	vdl.Register((*LogMessage)(nil))

	return struct{}{}
}
