// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Source: types.vdl

package vsync

import (
	"fmt"
	"v.io/v23/vdl"
	"v.io/x/ref/services/syncbase/server/interfaces"
)

// SyncData represents the persistent state of the sync module.
type SyncData struct {
	Id uint64
}

func (SyncData) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.SyncData"`
}) {
}

func (m *SyncData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_types_v_io_x_ref_services_syncbase_vsync_SyncData == nil || __VDLTypetypes0 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Id")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromUint(uint64(m.Id), vdl.Uint64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SyncData) MakeVDLTarget() vdl.Target {
	return &SyncDataTarget{Value: m}
}

type SyncDataTarget struct {
	Value *SyncData
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SyncDataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_SyncData) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_SyncData)
	}
	return t, nil
}
func (t *SyncDataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Id":
		val, err := &vdl.Uint64Target{Value: &t.Value.Id}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_types_v_io_x_ref_services_syncbase_vsync_SyncData)
	}
}
func (t *SyncDataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SyncDataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// DbSyncState represents the persistent sync state of a Database.
type DbSyncState struct {
	GenVecs   interfaces.Knowledge // knowledge capturing the locally-known generations of remote peers for data in Database.
	SgGenVecs interfaces.Knowledge // knowledge capturing the locally-known generations of remote peers for syncgroups in Database.
	IsPaused  bool                 // tracks whether sync is paused by client.
}

func (DbSyncState) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.DbSyncState"`
}) {
}

func (m *DbSyncState) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_types_v_io_x_ref_services_syncbase_vsync_DbSyncState == nil || __VDLTypetypes1 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("GenVecs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.GenVecs.FillVDLTarget(fieldTarget3, __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_Knowledge); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("SgGenVecs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.SgGenVecs.FillVDLTarget(fieldTarget5, __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_Knowledge); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("IsPaused")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromBool(bool(m.IsPaused), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *DbSyncState) MakeVDLTarget() vdl.Target {
	return &DbSyncStateTarget{Value: m}
}

type DbSyncStateTarget struct {
	Value *DbSyncState
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DbSyncStateTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_DbSyncState) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_DbSyncState)
	}
	return t, nil
}
func (t *DbSyncStateTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "GenVecs":
		val, err := &interfaces.KnowledgeTarget{Value: &t.Value.GenVecs}, error(nil)
		return nil, val, err
	case "SgGenVecs":
		val, err := &interfaces.KnowledgeTarget{Value: &t.Value.SgGenVecs}, error(nil)
		return nil, val, err
	case "IsPaused":
		val, err := &vdl.BoolTarget{Value: &t.Value.IsPaused}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_types_v_io_x_ref_services_syncbase_vsync_DbSyncState)
	}
}
func (t *DbSyncStateTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *DbSyncStateTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// LocalLogRec represents the persistent local state of a log record. Metadata
// is synced across peers, while pos is local-only.
type LocalLogRec struct {
	Metadata interfaces.LogRecMetadata
	Pos      uint64 // position in the Database log.
	Shell    bool   // indicates if the value was shelled by the sender.
}

func (LocalLogRec) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.LocalLogRec"`
}) {
}

func (m *LocalLogRec) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	__VDLEnsureNativeBuilt_types()
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Metadata")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Metadata.FillVDLTarget(fieldTarget3, __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Pos")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromUint(uint64(m.Pos), vdl.Uint64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Shell")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromBool(bool(m.Shell), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LocalLogRec) MakeVDLTarget() vdl.Target {
	return &LocalLogRecTarget{Value: m}
}

type LocalLogRecTarget struct {
	Value *LocalLogRec
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LocalLogRecTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec)
	}
	return t, nil
}
func (t *LocalLogRecTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Metadata":
		val, err := &interfaces.LogRecMetadataTarget{Value: &t.Value.Metadata}, error(nil)
		return nil, val, err
	case "Pos":
		val, err := &vdl.Uint64Target{Value: &t.Value.Pos}, error(nil)
		return nil, val, err
	case "Shell":
		val, err := &vdl.BoolTarget{Value: &t.Value.Shell}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec)
	}
}
func (t *LocalLogRecTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LocalLogRecTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// SgLocalState holds the syncgroup local state, only relevant to this member
// (i.e. the local Syncbase).  This is needed for crash recovery of the internal
// state transitions of the syncgroup.
type SgLocalState struct {
	// The count of local joiners to the same syncgroup.
	NumLocalJoiners uint32
	// The syncgroup is watched when the sync Watcher starts processing the
	// syncgroup data.  When a syncgroup is created or joined, an entry is
	// added to the Watcher queue (log) to inform it from which point to
	// start accepting store mutations, an asynchronous notification similar
	// to regular store mutations.  When the Watcher processes that queue
	// entry, it sets this bit to true.  When Syncbase restarts, the value
	// of this bit allows the new sync Watcher to recreate its in-memory
	// state by resuming to watch only the prefixes of syncgroups that were
	// previously being watched.
	Watched bool
	// The syncgroup was published here by this remote peer (if non-empty
	// string), typically the syncgroup creator.  In this case the syncgroup
	// cannot be GCed locally even if it has no local joiners.
	RemotePublisher string
	// The syncgroup is in pending state on a device that learns the current
	// state of the syncgroup from another device but has not yet received
	// through peer-to-peer sync the history of the changes (DAG and logs).
	// This happens in two cases:
	// 1- A joiner was accepted into a syncgroup by a syncgroup admin and
	//    only given the current syncgroup info synchronously and will
	//    receive the full history later via p2p sync.
	// 2- A remote server where the syncgroup is published was told by the
	//    syncgroup publisher the current syncgroup info synchronously and
	//    will receive the full history later via p2p sync.
	// The pending state is over when the device reaches or exceeds the
	// knowledge level indicated in the pending genvec.  While SyncPending
	// is true, no local syncgroup mutations are allowed (i.e. no join or
	// set-spec requests).
	SyncPending   bool
	PendingGenVec interfaces.GenVector
}

func (SgLocalState) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.SgLocalState"`
}) {
}

func (m *SgLocalState) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_types_v_io_x_ref_services_syncbase_vsync_SgLocalState == nil || __VDLTypetypes3 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("NumLocalJoiners")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromUint(uint64(m.NumLocalJoiners), vdl.Uint32Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Watched")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromBool(bool(m.Watched), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("RemotePublisher")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromString(string(m.RemotePublisher), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("SyncPending")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget9.FromBool(bool(m.SyncPending), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("PendingGenVec")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.PendingGenVec.FillVDLTarget(fieldTarget11, __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_GenVector); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SgLocalState) MakeVDLTarget() vdl.Target {
	return &SgLocalStateTarget{Value: m}
}

type SgLocalStateTarget struct {
	Value *SgLocalState
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SgLocalStateTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_SgLocalState) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_SgLocalState)
	}
	return t, nil
}
func (t *SgLocalStateTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "NumLocalJoiners":
		val, err := &vdl.Uint32Target{Value: &t.Value.NumLocalJoiners}, error(nil)
		return nil, val, err
	case "Watched":
		val, err := &vdl.BoolTarget{Value: &t.Value.Watched}, error(nil)
		return nil, val, err
	case "RemotePublisher":
		val, err := &vdl.StringTarget{Value: &t.Value.RemotePublisher}, error(nil)
		return nil, val, err
	case "SyncPending":
		val, err := &vdl.BoolTarget{Value: &t.Value.SyncPending}, error(nil)
		return nil, val, err
	case "PendingGenVec":
		val, err := &interfaces.GenVectorTarget{Value: &t.Value.PendingGenVec}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_types_v_io_x_ref_services_syncbase_vsync_SgLocalState)
	}
}
func (t *SgLocalStateTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SgLocalStateTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// DagNode holds the information on an object mutation in the DAG.  The node
// information is extracted from the log records exchanged between Syncbases.
// They are also stored in the DAG node to improve DAG traversal for conflict
// resolution and pruning without having to fetch the full log record.
type DagNode struct {
	Level    uint64   // node distance from root
	Parents  []string // references to parent versions
	Logrec   string   // reference to log record
	BatchId  uint64   // ID of a write batch
	Shell    bool     // true when the data is hidden due to permissions
	Deleted  bool     // true if the change was a delete
	PermId   string   // ID of the permissions controlling this version
	PermVers string   // current version of the permissions object
}

func (DagNode) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.DagNode"`
}) {
}

func (m *DagNode) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_types_v_io_x_ref_services_syncbase_vsync_DagNode == nil || __VDLTypetypes4 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Level")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromUint(uint64(m.Level), vdl.Uint64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Parents")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget6, err := fieldTarget5.StartList(__VDLTypetypes5, len(m.Parents))
		if err != nil {
			return err
		}
		for i, elem8 := range m.Parents {
			elemTarget7, err := listTarget6.StartElem(i)
			if err != nil {
				return err
			}
			if err := elemTarget7.FromString(string(elem8), vdl.StringType); err != nil {
				return err
			}
			if err := listTarget6.FinishElem(elemTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget5.FinishList(listTarget6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("Logrec")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget10.FromString(string(m.Logrec), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("BatchId")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget12.FromUint(uint64(m.BatchId), vdl.Uint64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("Shell")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget14.FromBool(bool(m.Shell), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
			return err
		}
	}
	keyTarget15, fieldTarget16, err := fieldsTarget1.StartField("Deleted")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget16.FromBool(bool(m.Deleted), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget15, fieldTarget16); err != nil {
			return err
		}
	}
	keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("PermId")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget18.FromString(string(m.PermId), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
			return err
		}
	}
	keyTarget19, fieldTarget20, err := fieldsTarget1.StartField("PermVers")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget20.FromString(string(m.PermVers), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget19, fieldTarget20); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *DagNode) MakeVDLTarget() vdl.Target {
	return &DagNodeTarget{Value: m}
}

type DagNodeTarget struct {
	Value *DagNode
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DagNodeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_DagNode) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_DagNode)
	}
	return t, nil
}
func (t *DagNodeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Level":
		val, err := &vdl.Uint64Target{Value: &t.Value.Level}, error(nil)
		return nil, val, err
	case "Parents":
		val, err := &vdl.StringSliceTarget{Value: &t.Value.Parents}, error(nil)
		return nil, val, err
	case "Logrec":
		val, err := &vdl.StringTarget{Value: &t.Value.Logrec}, error(nil)
		return nil, val, err
	case "BatchId":
		val, err := &vdl.Uint64Target{Value: &t.Value.BatchId}, error(nil)
		return nil, val, err
	case "Shell":
		val, err := &vdl.BoolTarget{Value: &t.Value.Shell}, error(nil)
		return nil, val, err
	case "Deleted":
		val, err := &vdl.BoolTarget{Value: &t.Value.Deleted}, error(nil)
		return nil, val, err
	case "PermId":
		val, err := &vdl.StringTarget{Value: &t.Value.PermId}, error(nil)
		return nil, val, err
	case "PermVers":
		val, err := &vdl.StringTarget{Value: &t.Value.PermVers}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_types_v_io_x_ref_services_syncbase_vsync_DagNode)
	}
}
func (t *DagNodeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *DagNodeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// BatchInfo holds the information on a write batch:
//  * The map of syncable (versioned) objects: {oid: version}
//  * The map of linked objects {oid: version} that were not explicitly written
//    as part of the batch but were reaffirmed during conflict resolution along
//    with other objects written in this batch by the app by choosing
//    "pickLocal" or "pickRemote". NOTE: this map is non empty only for batches
//    created during conflict resolution. Unlike the Objects map, the collection
//    of oid:version present in this map do not point back to this batch. They
//    point to the batches that there were originally created in.
//  * The total count of batch objects, including non-syncable ones.
// TODO(rdaoud): add support to track the read and scan sets.
type BatchInfo struct {
	Objects       map[string]string
	LinkedObjects map[string]string
	Count         uint64
}

func (BatchInfo) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.BatchInfo"`
}) {
}

func (m *BatchInfo) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_types_v_io_x_ref_services_syncbase_vsync_BatchInfo == nil || __VDLTypetypes6 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Objects")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(__VDLTypetypes7, len(m.Objects))
		if err != nil {
			return err
		}
		for key6, value8 := range m.Objects {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromString(string(key6), vdl.StringType); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}
			if err := valueTarget7.FromString(string(value8), vdl.StringType); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("LinkedObjects")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget11, err := fieldTarget10.StartMap(__VDLTypetypes7, len(m.LinkedObjects))
		if err != nil {
			return err
		}
		for key13, value15 := range m.LinkedObjects {
			keyTarget12, err := mapTarget11.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget12.FromString(string(key13), vdl.StringType); err != nil {
				return err
			}
			valueTarget14, err := mapTarget11.FinishKeyStartField(keyTarget12)
			if err != nil {
				return err
			}
			if err := valueTarget14.FromString(string(value15), vdl.StringType); err != nil {
				return err
			}
			if err := mapTarget11.FinishField(keyTarget12, valueTarget14); err != nil {
				return err
			}
		}
		if err := fieldTarget10.FinishMap(mapTarget11); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	keyTarget16, fieldTarget17, err := fieldsTarget1.StartField("Count")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget17.FromUint(uint64(m.Count), vdl.Uint64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget16, fieldTarget17); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BatchInfo) MakeVDLTarget() vdl.Target {
	return &BatchInfoTarget{Value: m}
}

type BatchInfoTarget struct {
	Value *BatchInfo
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BatchInfoTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_BatchInfo) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_types_v_io_x_ref_services_syncbase_vsync_BatchInfo)
	}
	return t, nil
}
func (t *BatchInfoTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Objects":
		val, err := &types6d61705b737472696e675d737472696e67Target{Value: &t.Value.Objects}, error(nil)
		return nil, val, err
	case "LinkedObjects":
		val, err := &types6d61705b737472696e675d737472696e67Target{Value: &t.Value.LinkedObjects}, error(nil)
		return nil, val, err
	case "Count":
		val, err := &vdl.Uint64Target{Value: &t.Value.Count}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_types_v_io_x_ref_services_syncbase_vsync_BatchInfo)
	}
}
func (t *BatchInfoTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BatchInfoTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type types6d61705b737472696e675d737472696e67Target struct {
	Value    *map[string]string
	currKey  string
	currElem string
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *types6d61705b737472696e675d737472696e67Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLTypetypes7) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLTypetypes7)
	}
	*t.Value = make(map[string]string)
	return t, nil
}
func (t *types6d61705b737472696e675d737472696e67Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	return &vdl.StringTarget{Value: &t.currKey}, error(nil)
}
func (t *types6d61705b737472696e675d737472696e67Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	return &vdl.StringTarget{Value: &t.currElem}, error(nil)
}
func (t *types6d61705b737472696e675d737472696e67Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *types6d61705b737472696e675d737472696e67Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func init() {
	vdl.Register((*SyncData)(nil))
	vdl.Register((*DbSyncState)(nil))
	vdl.Register((*LocalLogRec)(nil))
	vdl.Register((*SgLocalState)(nil))
	vdl.Register((*DagNode)(nil))
	vdl.Register((*BatchInfo)(nil))
}

var __VDLTypetypes6 *vdl.Type = vdl.TypeOf((*BatchInfo)(nil))
var __VDLTypetypes4 *vdl.Type = vdl.TypeOf((*DagNode)(nil))
var __VDLTypetypes1 *vdl.Type = vdl.TypeOf((*DbSyncState)(nil))
var __VDLTypetypes2 *vdl.Type

func __VDLTypetypes2_gen() *vdl.Type {
	__VDLTypetypes2Builder := vdl.TypeBuilder{}

	__VDLTypetypes21 := __VDLTypetypes2Builder.Optional()
	__VDLTypetypes22 := __VDLTypetypes2Builder.Struct()
	__VDLTypetypes23 := __VDLTypetypes2Builder.Named("v.io/x/ref/services/syncbase/vsync.LocalLogRec").AssignBase(__VDLTypetypes22)
	__VDLTypetypes24 := __VDLTypetypes2Builder.Struct()
	__VDLTypetypes25 := __VDLTypetypes2Builder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata").AssignBase(__VDLTypetypes24)
	__VDLTypetypes26 := vdl.Uint64Type
	__VDLTypetypes24.AppendField("Id", __VDLTypetypes26)
	__VDLTypetypes24.AppendField("Gen", __VDLTypetypes26)
	__VDLTypetypes27 := vdl.ByteType
	__VDLTypetypes24.AppendField("RecType", __VDLTypetypes27)
	__VDLTypetypes28 := vdl.StringType
	__VDLTypetypes24.AppendField("ObjId", __VDLTypetypes28)
	__VDLTypetypes24.AppendField("CurVers", __VDLTypetypes28)
	__VDLTypetypes29 := __VDLTypetypes2Builder.List()
	__VDLTypetypes29.AssignElem(__VDLTypetypes28)
	__VDLTypetypes24.AppendField("Parents", __VDLTypetypes29)
	__VDLTypetypes210 := __VDLTypetypes2Builder.Struct()
	__VDLTypetypes211 := __VDLTypetypes2Builder.Named("time.Time").AssignBase(__VDLTypetypes210)
	__VDLTypetypes212 := vdl.Int64Type
	__VDLTypetypes210.AppendField("Seconds", __VDLTypetypes212)
	__VDLTypetypes213 := vdl.Int32Type
	__VDLTypetypes210.AppendField("Nanos", __VDLTypetypes213)
	__VDLTypetypes24.AppendField("UpdTime", __VDLTypetypes211)
	__VDLTypetypes24.AppendField("PermId", __VDLTypetypes28)
	__VDLTypetypes24.AppendField("PermVers", __VDLTypetypes28)
	__VDLTypetypes214 := vdl.BoolType
	__VDLTypetypes24.AppendField("Delete", __VDLTypetypes214)
	__VDLTypetypes24.AppendField("BatchId", __VDLTypetypes26)
	__VDLTypetypes24.AppendField("BatchCount", __VDLTypetypes26)
	__VDLTypetypes22.AppendField("Metadata", __VDLTypetypes25)
	__VDLTypetypes22.AppendField("Pos", __VDLTypetypes26)
	__VDLTypetypes22.AppendField("Shell", __VDLTypetypes214)
	__VDLTypetypes21.AssignElem(__VDLTypetypes23)
	__VDLTypetypes2Builder.Build()
	__VDLTypetypes2v, err := __VDLTypetypes21.Built()
	if err != nil {
		panic(err)
	}
	return __VDLTypetypes2v
}
func init() {
	__VDLTypetypes2 = __VDLTypetypes2_gen()
}

var __VDLTypetypes3 *vdl.Type = vdl.TypeOf((*SgLocalState)(nil))
var __VDLTypetypes0 *vdl.Type = vdl.TypeOf((*SyncData)(nil))
var __VDLTypetypes5 *vdl.Type = vdl.TypeOf([]string(nil))
var __VDLTypetypes7 *vdl.Type = vdl.TypeOf(map[string]string(nil))
var __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_GenVector *vdl.Type = vdl.TypeOf(interfaces.GenVector(nil))
var __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_Knowledge *vdl.Type = vdl.TypeOf(interfaces.Knowledge(nil))
var __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata *vdl.Type

func __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata_gen() *vdl.Type {
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder := vdl.TypeBuilder{}

	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1 := __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.Struct()
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata2 := __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata").AssignBase(__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata3 := vdl.Uint64Type
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("Id", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata3)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("Gen", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata3)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata4 := vdl.ByteType
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("RecType", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata4)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5 := vdl.StringType
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("ObjId", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("CurVers", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata6 := __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.List()
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata6.AssignElem(__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("Parents", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata6)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata7 := __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.Struct()
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata8 := __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.Named("time.Time").AssignBase(__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata7)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata9 := vdl.Int64Type
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata7.AppendField("Seconds", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata9)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata10 := vdl.Int32Type
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata7.AppendField("Nanos", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata10)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("UpdTime", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata8)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("PermId", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("PermVers", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata5)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata11 := vdl.BoolType
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("Delete", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata11)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("BatchId", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata3)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata1.AppendField("BatchCount", __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata3)
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadataBuilder.Build()
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadatav, err := __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadatav
}
func init() {
	__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata = __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata_gen()
}

var __VDLType_types_v_io_x_ref_services_syncbase_vsync_BatchInfo *vdl.Type = vdl.TypeOf(BatchInfo{})
var __VDLType_types_v_io_x_ref_services_syncbase_vsync_DagNode *vdl.Type = vdl.TypeOf(DagNode{})
var __VDLType_types_v_io_x_ref_services_syncbase_vsync_DbSyncState *vdl.Type = vdl.TypeOf(DbSyncState{})
var __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec *vdl.Type

func __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec_gen() *vdl.Type {
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecBuilder := vdl.TypeBuilder{}

	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec1 := __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecBuilder.Struct()
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec2 := __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecBuilder.Named("v.io/x/ref/services/syncbase/vsync.LocalLogRec").AssignBase(__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec1)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3 := __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecBuilder.Struct()
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec4 := __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecBuilder.Named("v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata").AssignBase(__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec5 := vdl.Uint64Type
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("Id", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec5)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("Gen", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec5)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec6 := vdl.ByteType
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("RecType", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec6)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec7 := vdl.StringType
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("ObjId", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec7)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("CurVers", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec7)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec8 := __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecBuilder.List()
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec8.AssignElem(__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec7)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("Parents", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec8)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec9 := __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecBuilder.Struct()
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec10 := __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecBuilder.Named("time.Time").AssignBase(__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec9)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec11 := vdl.Int64Type
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec9.AppendField("Seconds", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec11)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec12 := vdl.Int32Type
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec9.AppendField("Nanos", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec12)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("UpdTime", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec10)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("PermId", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec7)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("PermVers", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec7)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec13 := vdl.BoolType
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("Delete", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec13)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("BatchId", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec5)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec3.AppendField("BatchCount", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec5)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec1.AppendField("Metadata", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec4)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec1.AppendField("Pos", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec5)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec1.AppendField("Shell", __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec13)
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecBuilder.Build()
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecv, err := __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec2.Built()
	if err != nil {
		panic(err)
	}
	return __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRecv
}
func init() {
	__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec = __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec_gen()
}

var __VDLType_types_v_io_x_ref_services_syncbase_vsync_SgLocalState *vdl.Type = vdl.TypeOf(SgLocalState{})
var __VDLType_types_v_io_x_ref_services_syncbase_vsync_SyncData *vdl.Type = vdl.TypeOf(SyncData{})

func __VDLEnsureNativeBuilt_types() {
	if __VDLTypetypes2 == nil {
		__VDLTypetypes2 = __VDLTypetypes2_gen()
	}
	if __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata == nil {
		__VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata = __VDLType_types_v_io_x_ref_services_syncbase_server_interfaces_LogRecMetadata_gen()
	}
	if __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec == nil {
		__VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec = __VDLType_types_v_io_x_ref_services_syncbase_vsync_LocalLogRec_gen()
	}
}
