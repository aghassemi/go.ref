// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: vsync

package vsync

import (
	"fmt"
	"v.io/v23/vdl"
	"v.io/v23/vdlroot/time"
	"v.io/x/ref/services/syncbase/server/interfaces"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// SyncData represents the persistent state of the sync module.
type SyncData struct {
	Id uint64
}

func (SyncData) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.SyncData"`
}) {
}

func (m *SyncData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Id == uint64(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("Id"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Id")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromUint(uint64(m.Id), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SyncData) MakeVDLTarget() vdl.Target {
	return &SyncDataTarget{Value: m}
}

type SyncDataTarget struct {
	Value    *SyncData
	idTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SyncDataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*SyncData)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *SyncDataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Id":
		t.idTarget.Value = &t.Value.Id
		target, err := &t.idTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.SyncData", name)
	}
}
func (t *SyncDataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SyncDataTarget) ZeroField(name string) error {
	switch name {
	case "Id":
		t.Value.Id = uint64(0)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.SyncData", name)
	}
}
func (t *SyncDataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *SyncData) VDLRead(dec vdl.Decoder) error {
	*x = SyncData{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Id":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Id, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func (x SyncData) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SyncData)(nil)).Elem()); err != nil {
		return err
	}
	var1 := (x.Id == uint64(0))
	if !(var1) {
		if err := enc.NextField("Id"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*uint64)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeUint(x.Id); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

// DbSyncState represents the persistent sync state of a Database.
type DbSyncState struct {
	GenVecs   interfaces.Knowledge // knowledge capturing the locally-known generations of remote peers for data in Database.
	SgGenVecs interfaces.Knowledge // knowledge capturing the locally-known generations of remote peers for syncgroups in Database.
	IsPaused  bool                 // tracks whether sync is paused by client.
}

func (DbSyncState) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.DbSyncState"`
}) {
}

func (m *DbSyncState) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.GenVecs) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("GenVecs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("GenVecs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.GenVecs.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.SgGenVecs) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("SgGenVecs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("SgGenVecs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.SgGenVecs.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.IsPaused == false)
	if var10 {
		if err := fieldsTarget1.ZeroField("IsPaused"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("IsPaused")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromBool(bool(m.IsPaused), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *DbSyncState) MakeVDLTarget() vdl.Target {
	return &DbSyncStateTarget{Value: m}
}

type DbSyncStateTarget struct {
	Value           *DbSyncState
	genVecsTarget   interfaces.KnowledgeTarget
	sgGenVecsTarget interfaces.KnowledgeTarget
	isPausedTarget  vdl.BoolTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DbSyncStateTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*DbSyncState)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *DbSyncStateTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "GenVecs":
		t.genVecsTarget.Value = &t.Value.GenVecs
		target, err := &t.genVecsTarget, error(nil)
		return nil, target, err
	case "SgGenVecs":
		t.sgGenVecsTarget.Value = &t.Value.SgGenVecs
		target, err := &t.sgGenVecsTarget, error(nil)
		return nil, target, err
	case "IsPaused":
		t.isPausedTarget.Value = &t.Value.IsPaused
		target, err := &t.isPausedTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.DbSyncState", name)
	}
}
func (t *DbSyncStateTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *DbSyncStateTarget) ZeroField(name string) error {
	switch name {
	case "GenVecs":
		t.Value.GenVecs = interfaces.Knowledge(nil)
		return nil
	case "SgGenVecs":
		t.Value.SgGenVecs = interfaces.Knowledge(nil)
		return nil
	case "IsPaused":
		t.Value.IsPaused = false
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.DbSyncState", name)
	}
}
func (t *DbSyncStateTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *DbSyncState) VDLRead(dec vdl.Decoder) error {
	*x = DbSyncState{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "GenVecs":
			if err = x.GenVecs.VDLRead(dec); err != nil {
				return err
			}
		case "SgGenVecs":
			if err = x.SgGenVecs.VDLRead(dec); err != nil {
				return err
			}
		case "IsPaused":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.IsPaused, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func (x DbSyncState) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*DbSyncState)(nil)).Elem()); err != nil {
		return err
	}
	var var1 bool
	if len(x.GenVecs) == 0 {
		var1 = true
	}
	if !(var1) {
		if err := enc.NextField("GenVecs"); err != nil {
			return err
		}
		if err := x.GenVecs.VDLWrite(enc); err != nil {
			return err
		}
	}
	var var2 bool
	if len(x.SgGenVecs) == 0 {
		var2 = true
	}
	if !(var2) {
		if err := enc.NextField("SgGenVecs"); err != nil {
			return err
		}
		if err := x.SgGenVecs.VDLWrite(enc); err != nil {
			return err
		}
	}
	var3 := (x.IsPaused == false)
	if !(var3) {
		if err := enc.NextField("IsPaused"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*bool)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.IsPaused); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

// LocalLogRec represents the persistent local state of a log record. Metadata
// is synced across peers, while pos is local-only.
type LocalLogRec struct {
	Metadata interfaces.LogRecMetadata
	Pos      uint64 // position in the Database log.
}

func (LocalLogRec) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.LocalLogRec"`
}) {
}

func (m *LocalLogRec) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := true
	var5 := (m.Metadata.Id == uint64(0))
	var4 = var4 && var5
	var6 := (m.Metadata.Gen == uint64(0))
	var4 = var4 && var6
	var7 := (m.Metadata.RecType == byte(0))
	var4 = var4 && var7
	var8 := (m.Metadata.ObjId == "")
	var4 = var4 && var8
	var9 := (m.Metadata.CurVers == "")
	var4 = var4 && var9
	var var10 bool
	if len(m.Metadata.Parents) == 0 {
		var10 = true
	}
	var4 = var4 && var10
	var wireValue11 time.Time
	if err := time.TimeFromNative(&wireValue11, m.Metadata.UpdTime); err != nil {
		return fmt.Errorf("error converting m.Metadata.UpdTime to wiretype")
	}

	var12 := (wireValue11 == time.Time{})
	var4 = var4 && var12
	var13 := (m.Metadata.Delete == false)
	var4 = var4 && var13
	var14 := (m.Metadata.BatchId == uint64(0))
	var4 = var4 && var14
	var15 := (m.Metadata.BatchCount == uint64(0))
	var4 = var4 && var15
	if var4 {
		if err := fieldsTarget1.ZeroField("Metadata"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Metadata")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Metadata.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var18 := (m.Pos == uint64(0))
	if var18 {
		if err := fieldsTarget1.ZeroField("Pos"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget16, fieldTarget17, err := fieldsTarget1.StartField("Pos")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget17.FromUint(uint64(m.Pos), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget16, fieldTarget17); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LocalLogRec) MakeVDLTarget() vdl.Target {
	return &LocalLogRecTarget{Value: m}
}

type LocalLogRecTarget struct {
	Value          *LocalLogRec
	metadataTarget interfaces.LogRecMetadataTarget
	posTarget      vdl.Uint64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LocalLogRecTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LocalLogRec)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LocalLogRecTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Metadata":
		t.metadataTarget.Value = &t.Value.Metadata
		target, err := &t.metadataTarget, error(nil)
		return nil, target, err
	case "Pos":
		t.posTarget.Value = &t.Value.Pos
		target, err := &t.posTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.LocalLogRec", name)
	}
}
func (t *LocalLogRecTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LocalLogRecTarget) ZeroField(name string) error {
	switch name {
	case "Metadata":
		t.Value.Metadata = interfaces.LogRecMetadata{}
		return nil
	case "Pos":
		t.Value.Pos = uint64(0)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.LocalLogRec", name)
	}
}
func (t *LocalLogRecTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *LocalLogRec) VDLRead(dec vdl.Decoder) error {
	*x = LocalLogRec{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Metadata":
			if err = x.Metadata.VDLRead(dec); err != nil {
				return err
			}
		case "Pos":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Pos, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func (x LocalLogRec) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*LocalLogRec)(nil)).Elem()); err != nil {
		return err
	}
	var1 := true
	var2 := (x.Metadata.Id == uint64(0))
	var1 = var1 && var2
	var3 := (x.Metadata.Gen == uint64(0))
	var1 = var1 && var3
	var4 := (x.Metadata.RecType == byte(0))
	var1 = var1 && var4
	var5 := (x.Metadata.ObjId == "")
	var1 = var1 && var5
	var6 := (x.Metadata.CurVers == "")
	var1 = var1 && var6
	var var7 bool
	if len(x.Metadata.Parents) == 0 {
		var7 = true
	}
	var1 = var1 && var7
	var wireValue8 time.Time
	if err := time.TimeFromNative(&wireValue8, x.Metadata.UpdTime); err != nil {
		return fmt.Errorf("error converting x.Metadata.UpdTime to wiretype")
	}

	var9 := (wireValue8 == time.Time{})
	var1 = var1 && var9
	var10 := (x.Metadata.Delete == false)
	var1 = var1 && var10
	var11 := (x.Metadata.BatchId == uint64(0))
	var1 = var1 && var11
	var12 := (x.Metadata.BatchCount == uint64(0))
	var1 = var1 && var12
	if !(var1) {
		if err := enc.NextField("Metadata"); err != nil {
			return err
		}
		if err := x.Metadata.VDLWrite(enc); err != nil {
			return err
		}
	}
	var13 := (x.Pos == uint64(0))
	if !(var13) {
		if err := enc.NextField("Pos"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*uint64)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeUint(x.Pos); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

// SgLocalState holds the syncgroup local state, only relevant to this member
// (i.e. the local Syncbase).  This is needed for crash recovery of the internal
// state transitions of the syncgroup.
type SgLocalState struct {
	// The count of local joiners to the same syncgroup.
	NumLocalJoiners uint32
	// The syncgroup is watched when the sync Watcher starts processing the
	// syncgroup data.  When a syncgroup is created or joined, an entry is
	// added to the Watcher queue (log) to inform it from which point to
	// start accepting store mutations, an asynchronous notification similar
	// to regular store mutations.  When the Watcher processes that queue
	// entry, it sets this bit to true.  When Syncbase restarts, the value
	// of this bit allows the new sync Watcher to recreate its in-memory
	// state by resuming to watch only the prefixes of syncgroups that were
	// previously being watched.
	Watched bool
	// The syncgroup was published here by this remote peer (if non-empty
	// string), typically the syncgroup creator.  In this case the syncgroup
	// cannot be GCed locally even if it has no local joiners.
	RemotePublisher string
	// The syncgroup is in pending state on a device that learns the current
	// state of the syncgroup from another device but has not yet received
	// through peer-to-peer sync the history of the changes (DAG and logs).
	// This happens in two cases:
	// 1- A joiner was accepted into a syncgroup by a syncgroup admin and
	//    only given the current syncgroup info synchronously and will
	//    receive the full history later via p2p sync.
	// 2- A remote server where the syncgroup is published was told by the
	//    syncgroup publisher the current syncgroup info synchronously and
	//    will receive the full history later via p2p sync.
	// The pending state is over when the device reaches or exceeds the
	// knowledge level indicated in the pending genvec.  While SyncPending
	// is true, no local syncgroup mutations are allowed (i.e. no join or
	// set-spec requests).
	SyncPending   bool
	PendingGenVec interfaces.GenVector
}

func (SgLocalState) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.SgLocalState"`
}) {
}

func (m *SgLocalState) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.NumLocalJoiners == uint32(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("NumLocalJoiners"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("NumLocalJoiners")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromUint(uint64(m.NumLocalJoiners), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Watched == false)
	if var7 {
		if err := fieldsTarget1.ZeroField("Watched"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Watched")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromBool(bool(m.Watched), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.RemotePublisher == "")
	if var10 {
		if err := fieldsTarget1.ZeroField("RemotePublisher"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("RemotePublisher")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromString(string(m.RemotePublisher), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.SyncPending == false)
	if var13 {
		if err := fieldsTarget1.ZeroField("SyncPending"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("SyncPending")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromBool(bool(m.SyncPending), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var var16 bool
	if len(m.PendingGenVec) == 0 {
		var16 = true
	}
	if var16 {
		if err := fieldsTarget1.ZeroField("PendingGenVec"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("PendingGenVec")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.PendingGenVec.FillVDLTarget(fieldTarget15, tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SgLocalState) MakeVDLTarget() vdl.Target {
	return &SgLocalStateTarget{Value: m}
}

type SgLocalStateTarget struct {
	Value                 *SgLocalState
	numLocalJoinersTarget vdl.Uint32Target
	watchedTarget         vdl.BoolTarget
	remotePublisherTarget vdl.StringTarget
	syncPendingTarget     vdl.BoolTarget
	pendingGenVecTarget   interfaces.GenVectorTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SgLocalStateTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*SgLocalState)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *SgLocalStateTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "NumLocalJoiners":
		t.numLocalJoinersTarget.Value = &t.Value.NumLocalJoiners
		target, err := &t.numLocalJoinersTarget, error(nil)
		return nil, target, err
	case "Watched":
		t.watchedTarget.Value = &t.Value.Watched
		target, err := &t.watchedTarget, error(nil)
		return nil, target, err
	case "RemotePublisher":
		t.remotePublisherTarget.Value = &t.Value.RemotePublisher
		target, err := &t.remotePublisherTarget, error(nil)
		return nil, target, err
	case "SyncPending":
		t.syncPendingTarget.Value = &t.Value.SyncPending
		target, err := &t.syncPendingTarget, error(nil)
		return nil, target, err
	case "PendingGenVec":
		t.pendingGenVecTarget.Value = &t.Value.PendingGenVec
		target, err := &t.pendingGenVecTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.SgLocalState", name)
	}
}
func (t *SgLocalStateTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SgLocalStateTarget) ZeroField(name string) error {
	switch name {
	case "NumLocalJoiners":
		t.Value.NumLocalJoiners = uint32(0)
		return nil
	case "Watched":
		t.Value.Watched = false
		return nil
	case "RemotePublisher":
		t.Value.RemotePublisher = ""
		return nil
	case "SyncPending":
		t.Value.SyncPending = false
		return nil
	case "PendingGenVec":
		t.Value.PendingGenVec = interfaces.GenVector(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.SgLocalState", name)
	}
}
func (t *SgLocalStateTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *SgLocalState) VDLRead(dec vdl.Decoder) error {
	*x = SgLocalState{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "NumLocalJoiners":
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			x.NumLocalJoiners = uint32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Watched":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Watched, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "RemotePublisher":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.RemotePublisher, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "SyncPending":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.SyncPending, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "PendingGenVec":
			if err = x.PendingGenVec.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func (x SgLocalState) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SgLocalState)(nil)).Elem()); err != nil {
		return err
	}
	var1 := (x.NumLocalJoiners == uint32(0))
	if !(var1) {
		if err := enc.NextField("NumLocalJoiners"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*uint32)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.NumLocalJoiners)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	var2 := (x.Watched == false)
	if !(var2) {
		if err := enc.NextField("Watched"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*bool)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Watched); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	var3 := (x.RemotePublisher == "")
	if !(var3) {
		if err := enc.NextField("RemotePublisher"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*string)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeString(x.RemotePublisher); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	var4 := (x.SyncPending == false)
	if !(var4) {
		if err := enc.NextField("SyncPending"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*bool)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.SyncPending); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	var var5 bool
	if len(x.PendingGenVec) == 0 {
		var5 = true
	}
	if !(var5) {
		if err := enc.NextField("PendingGenVec"); err != nil {
			return err
		}
		if err := x.PendingGenVec.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

// DagNode holds the information on an object mutation in the DAG.  The node
// information is extracted from the log records exchanged between Syncbases.
// They are also stored in the DAG node to improve DAG traversal for conflict
// resolution and pruning without having to fetch the full log record.
type DagNode struct {
	Level    uint64   // node distance from root
	Parents  []string // references to parent versions
	Logrec   string   // reference to log record
	BatchId  uint64   // ID of a write batch
	Deleted  bool     // true if the change was a delete
	PermId   string   // ID of the permissions controlling this version
	PermVers string   // current version of the permissions object
}

func (DagNode) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.DagNode"`
}) {
}

func (m *DagNode) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Level == uint64(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("Level"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Level")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromUint(uint64(m.Level), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.Parents) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("Parents"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Parents")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget8, err := fieldTarget6.StartList(tt.NonOptional().Field(1).Type, len(m.Parents))
			if err != nil {
				return err
			}
			for i, elem10 := range m.Parents {
				elemTarget9, err := listTarget8.StartElem(i)
				if err != nil {
					return err
				}
				if err := elemTarget9.FromString(string(elem10), tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget8.FinishElem(elemTarget9); err != nil {
					return err
				}
			}
			if err := fieldTarget6.FinishList(listTarget8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var13 := (m.Logrec == "")
	if var13 {
		if err := fieldsTarget1.ZeroField("Logrec"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Logrec")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromString(string(m.Logrec), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var16 := (m.BatchId == uint64(0))
	if var16 {
		if err := fieldsTarget1.ZeroField("BatchId"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("BatchId")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget15.FromUint(uint64(m.BatchId), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var19 := (m.Deleted == false)
	if var19 {
		if err := fieldsTarget1.ZeroField("Deleted"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("Deleted")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget18.FromBool(bool(m.Deleted), tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
				return err
			}
		}
	}
	var22 := (m.PermId == "")
	if var22 {
		if err := fieldsTarget1.ZeroField("PermId"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("PermId")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget21.FromString(string(m.PermId), tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
				return err
			}
		}
	}
	var25 := (m.PermVers == "")
	if var25 {
		if err := fieldsTarget1.ZeroField("PermVers"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("PermVers")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget24.FromString(string(m.PermVers), tt.NonOptional().Field(6).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *DagNode) MakeVDLTarget() vdl.Target {
	return &DagNodeTarget{Value: m}
}

type DagNodeTarget struct {
	Value          *DagNode
	levelTarget    vdl.Uint64Target
	parentsTarget  vdl.StringSliceTarget
	logrecTarget   vdl.StringTarget
	batchIdTarget  vdl.Uint64Target
	deletedTarget  vdl.BoolTarget
	permIdTarget   vdl.StringTarget
	permVersTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DagNodeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*DagNode)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *DagNodeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Level":
		t.levelTarget.Value = &t.Value.Level
		target, err := &t.levelTarget, error(nil)
		return nil, target, err
	case "Parents":
		t.parentsTarget.Value = &t.Value.Parents
		target, err := &t.parentsTarget, error(nil)
		return nil, target, err
	case "Logrec":
		t.logrecTarget.Value = &t.Value.Logrec
		target, err := &t.logrecTarget, error(nil)
		return nil, target, err
	case "BatchId":
		t.batchIdTarget.Value = &t.Value.BatchId
		target, err := &t.batchIdTarget, error(nil)
		return nil, target, err
	case "Deleted":
		t.deletedTarget.Value = &t.Value.Deleted
		target, err := &t.deletedTarget, error(nil)
		return nil, target, err
	case "PermId":
		t.permIdTarget.Value = &t.Value.PermId
		target, err := &t.permIdTarget, error(nil)
		return nil, target, err
	case "PermVers":
		t.permVersTarget.Value = &t.Value.PermVers
		target, err := &t.permVersTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.DagNode", name)
	}
}
func (t *DagNodeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *DagNodeTarget) ZeroField(name string) error {
	switch name {
	case "Level":
		t.Value.Level = uint64(0)
		return nil
	case "Parents":
		t.Value.Parents = []string(nil)
		return nil
	case "Logrec":
		t.Value.Logrec = ""
		return nil
	case "BatchId":
		t.Value.BatchId = uint64(0)
		return nil
	case "Deleted":
		t.Value.Deleted = false
		return nil
	case "PermId":
		t.Value.PermId = ""
		return nil
	case "PermVers":
		t.Value.PermVers = ""
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.DagNode", name)
	}
}
func (t *DagNodeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *DagNode) VDLRead(dec vdl.Decoder) error {
	*x = DagNode{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Level":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Level, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Parents":
			if err = __VDLRead1_list(dec, &x.Parents); err != nil {
				return err
			}
		case "Logrec":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Logrec, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "BatchId":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.BatchId, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Deleted":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Deleted, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "PermId":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.PermId, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "PermVers":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.PermVers, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead1_list(dec vdl.Decoder, x *[]string) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]string, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem string
		if err = dec.StartValue(); err != nil {
			return err
		}
		if elem, err = dec.DecodeString(); err != nil {
			return err
		}
		if err = dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func (x DagNode) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*DagNode)(nil)).Elem()); err != nil {
		return err
	}
	var1 := (x.Level == uint64(0))
	if !(var1) {
		if err := enc.NextField("Level"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*uint64)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeUint(x.Level); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	var var2 bool
	if len(x.Parents) == 0 {
		var2 = true
	}
	if !(var2) {
		if err := enc.NextField("Parents"); err != nil {
			return err
		}
		if err := __VDLWrite1_list(enc, &x.Parents); err != nil {
			return err
		}
	}
	var3 := (x.Logrec == "")
	if !(var3) {
		if err := enc.NextField("Logrec"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*string)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Logrec); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	var4 := (x.BatchId == uint64(0))
	if !(var4) {
		if err := enc.NextField("BatchId"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*uint64)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeUint(x.BatchId); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	var5 := (x.Deleted == false)
	if !(var5) {
		if err := enc.NextField("Deleted"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*bool)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Deleted); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	var6 := (x.PermId == "")
	if !(var6) {
		if err := enc.NextField("PermId"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*string)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeString(x.PermId); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	var7 := (x.PermVers == "")
	if !(var7) {
		if err := enc.NextField("PermVers"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*string)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeString(x.PermVers); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWrite1_list(enc vdl.Encoder, x *[]string) error {
	if err := enc.StartValue(vdl.TypeOf((*[]string)(nil))); err != nil {
		return err
	}
	for i := 0; i < len(*x); i++ {
		if err := enc.StartValue(vdl.TypeOf((*string)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeString((*x)[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

// BatchInfo holds the information on a write batch:
//  * The map of syncable (versioned) objects: {oid: version}
//  * The map of linked objects {oid: version} that were not explicitly written
//    as part of the batch but were reaffirmed during conflict resolution along
//    with other objects written in this batch by the app by choosing
//    "pickLocal" or "pickRemote". NOTE: this map is non empty only for batches
//    created during conflict resolution. Unlike the Objects map, the collection
//    of oid:version present in this map do not point back to this batch. They
//    point to the batches that there were originally created in.
//  * The total count of batch objects, including non-syncable ones.
// TODO(rdaoud): add support to track the read and scan sets.
type BatchInfo struct {
	Objects       map[string]string
	LinkedObjects map[string]string
	Count         uint64
}

func (BatchInfo) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/vsync.BatchInfo"`
}) {
}

func (m *BatchInfo) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.Objects) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("Objects"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Objects")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget5, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.Objects))
			if err != nil {
				return err
			}
			for key7, value9 := range m.Objects {
				keyTarget6, err := mapTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromString(string(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				valueTarget8, err := mapTarget5.FinishKeyStartField(keyTarget6)
				if err != nil {
					return err
				}
				if err := valueTarget8.FromString(string(value9), tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget5.FinishField(keyTarget6, valueTarget8); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishMap(mapTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var12 bool
	if len(m.LinkedObjects) == 0 {
		var12 = true
	}
	if var12 {
		if err := fieldsTarget1.ZeroField("LinkedObjects"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("LinkedObjects")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget13, err := fieldTarget11.StartMap(tt.NonOptional().Field(1).Type, len(m.LinkedObjects))
			if err != nil {
				return err
			}
			for key15, value17 := range m.LinkedObjects {
				keyTarget14, err := mapTarget13.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget14.FromString(string(key15), tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				valueTarget16, err := mapTarget13.FinishKeyStartField(keyTarget14)
				if err != nil {
					return err
				}
				if err := valueTarget16.FromString(string(value17), tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget13.FinishField(keyTarget14, valueTarget16); err != nil {
					return err
				}
			}
			if err := fieldTarget11.FinishMap(mapTarget13); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
				return err
			}
		}
	}
	var20 := (m.Count == uint64(0))
	if var20 {
		if err := fieldsTarget1.ZeroField("Count"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("Count")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget19.FromUint(uint64(m.Count), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BatchInfo) MakeVDLTarget() vdl.Target {
	return &BatchInfoTarget{Value: m}
}

type BatchInfoTarget struct {
	Value               *BatchInfo
	objectsTarget       __VDLTarget1_map
	linkedObjectsTarget __VDLTarget1_map
	countTarget         vdl.Uint64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BatchInfoTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*BatchInfo)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *BatchInfoTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Objects":
		t.objectsTarget.Value = &t.Value.Objects
		target, err := &t.objectsTarget, error(nil)
		return nil, target, err
	case "LinkedObjects":
		t.linkedObjectsTarget.Value = &t.Value.LinkedObjects
		target, err := &t.linkedObjectsTarget, error(nil)
		return nil, target, err
	case "Count":
		t.countTarget.Value = &t.Value.Count
		target, err := &t.countTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.BatchInfo", name)
	}
}
func (t *BatchInfoTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BatchInfoTarget) ZeroField(name string) error {
	switch name {
	case "Objects":
		t.Value.Objects = map[string]string(nil)
		return nil
	case "LinkedObjects":
		t.Value.LinkedObjects = map[string]string(nil)
		return nil
	case "Count":
		t.Value.Count = uint64(0)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/vsync.BatchInfo", name)
	}
}
func (t *BatchInfoTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[string]string
type __VDLTarget1_map struct {
	Value      *map[string]string
	currKey    string
	currElem   string
	keyTarget  vdl.StringTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget1_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]string)
	return t, nil
}
func (t *__VDLTarget1_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget1_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *BatchInfo) VDLRead(dec vdl.Decoder) error {
	*x = BatchInfo{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Objects":
			if err = __VDLRead2_map(dec, &x.Objects); err != nil {
				return err
			}
		case "LinkedObjects":
			if err = __VDLRead2_map(dec, &x.LinkedObjects); err != nil {
				return err
			}
		case "Count":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Count, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead2_map(dec vdl.Decoder, x *map[string]string) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string]string)
		}
		tmpMap[key] = elem
	}
}

func (x BatchInfo) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BatchInfo)(nil)).Elem()); err != nil {
		return err
	}
	var var1 bool
	if len(x.Objects) == 0 {
		var1 = true
	}
	if !(var1) {
		if err := enc.NextField("Objects"); err != nil {
			return err
		}
		if err := __VDLWrite2_map(enc, &x.Objects); err != nil {
			return err
		}
	}
	var var2 bool
	if len(x.LinkedObjects) == 0 {
		var2 = true
	}
	if !(var2) {
		if err := enc.NextField("LinkedObjects"); err != nil {
			return err
		}
		if err := __VDLWrite2_map(enc, &x.LinkedObjects); err != nil {
			return err
		}
	}
	var3 := (x.Count == uint64(0))
	if !(var3) {
		if err := enc.NextField("Count"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*uint64)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeUint(x.Count); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWrite2_map(enc vdl.Encoder, x *map[string]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string]string)(nil))); err != nil {
		return err
	}
	for key, elem := range *x {
		if err := enc.StartValue(vdl.TypeOf((*string)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*string)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*SyncData)(nil))
	vdl.Register((*DbSyncState)(nil))
	vdl.Register((*LocalLogRec)(nil))
	vdl.Register((*SgLocalState)(nil))
	vdl.Register((*DagNode)(nil))
	vdl.Register((*BatchInfo)(nil))

	return struct{}{}
}
