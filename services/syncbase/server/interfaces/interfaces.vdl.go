// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: interfaces

package interfaces

import (
	"fmt"
	"io"
	"reflect"
	"time"
	"v.io/v23"
	"v.io/v23/context"
	"v.io/v23/i18n"
	"v.io/v23/rpc"
	"v.io/v23/security/access"
	"v.io/v23/services/syncbase"
	"v.io/v23/vdl"
	time_2 "v.io/v23/vdlroot/time"
	"v.io/v23/verror"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// GenVector is the generation vector for any syncable entity, which maps each
// device id to its last locally known generation in the scope of that entity.
type GenVector map[uint64]uint64

func (GenVector) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.GenVector"`
}) {
}

func (m *GenVector) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromUint(uint64(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *GenVector) MakeVDLTarget() vdl.Target {
	return &GenVectorTarget{Value: m}
}

type GenVectorTarget struct {
	Value      *GenVector
	currKey    uint64
	currElem   uint64
	keyTarget  vdl.Uint64Target
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *GenVectorTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*GenVector)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(GenVector)
	return t, nil
}
func (t *GenVectorTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *GenVectorTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = uint64(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *GenVectorTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *GenVectorTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *GenVector) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap GenVector
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(GenVector, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint64
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem uint64
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if elem, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(GenVector)
		}
		tmpMap[key] = elem
	}
}

// Knowledge is a mapping of syncable entities to their generation
// vectors. These syncable entities could be data prefixes relative to a
// Database id, or syncgroup oids.
type Knowledge map[string]GenVector

func (Knowledge) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.Knowledge"`
}) {
}

func (m *Knowledge) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Knowledge) MakeVDLTarget() vdl.Target {
	return &KnowledgeTarget{Value: m}
}

type KnowledgeTarget struct {
	Value      *Knowledge
	currKey    string
	currElem   GenVector
	keyTarget  vdl.StringTarget
	elemTarget GenVectorTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *KnowledgeTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*Knowledge)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(Knowledge)
	return t, nil
}
func (t *KnowledgeTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *KnowledgeTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = GenVector(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *KnowledgeTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *KnowledgeTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *Knowledge) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap Knowledge
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(Knowledge, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem GenVector
		{
			if err = elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(Knowledge)
		}
		tmpMap[key] = elem
	}
}

// LogRecMetadata represents the metadata of a single log record that is
// exchanged between two peers. Each log record represents a change made to an
// object in the store.
//
// TODO(hpucha): Add readset/scanset. Look into sending tx metadata only once
// per transaction.
type LogRecMetadata struct {
	// Log related information.
	Id      uint64 // device id that created the log record.
	Gen     uint64 // generation number for the log record.
	RecType byte   // type of log record.
	// Id of the object that was updated. This id is relative to Application
	// and Database names and is the store key for a particular row in a
	// collection.
	ObjId      string
	CurVers    string    // current version number of the object.
	Parents    []string  // 0, 1 or 2 parent versions that the current version is derived from.
	UpdTime    time.Time // timestamp when the update is generated.
	Delete     bool      // indicates whether the update resulted in object being deleted from the store.
	BatchId    uint64    // unique id of the Batch this update belongs to.
	BatchCount uint64    // number of objects in the Batch.
}

func (LogRecMetadata) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata"`
}) {
}

func (m *LogRecMetadata) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Id == uint64(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("Id"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Id")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromUint(uint64(m.Id), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Gen == uint64(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Gen"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Gen")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromUint(uint64(m.Gen), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.RecType == byte(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("RecType"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("RecType")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromUint(uint64(m.RecType), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.ObjId == "")
	if var13 {
		if err := fieldsTarget1.ZeroField("ObjId"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("ObjId")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromString(string(m.ObjId), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var16 := (m.CurVers == "")
	if var16 {
		if err := fieldsTarget1.ZeroField("CurVers"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("CurVers")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget15.FromString(string(m.CurVers), tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var var19 bool
	if len(m.Parents) == 0 {
		var19 = true
	}
	if var19 {
		if err := fieldsTarget1.ZeroField("Parents"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("Parents")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget20, err := fieldTarget18.StartList(tt.NonOptional().Field(5).Type, len(m.Parents))
			if err != nil {
				return err
			}
			for i, elem22 := range m.Parents {
				elemTarget21, err := listTarget20.StartElem(i)
				if err != nil {
					return err
				}
				if err := elemTarget21.FromString(string(elem22), tt.NonOptional().Field(5).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget20.FinishElem(elemTarget21); err != nil {
					return err
				}
			}
			if err := fieldTarget18.FinishList(listTarget20); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
				return err
			}
		}
	}
	var wireValue23 time_2.Time
	if err := time_2.TimeFromNative(&wireValue23, m.UpdTime); err != nil {
		return err
	}

	var26 := (wireValue23 == time_2.Time{})
	if var26 {
		if err := fieldsTarget1.ZeroField("UpdTime"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget24, fieldTarget25, err := fieldsTarget1.StartField("UpdTime")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue23.FillVDLTarget(fieldTarget25, tt.NonOptional().Field(6).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget24, fieldTarget25); err != nil {
				return err
			}
		}
	}
	var29 := (m.Delete == false)
	if var29 {
		if err := fieldsTarget1.ZeroField("Delete"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget27, fieldTarget28, err := fieldsTarget1.StartField("Delete")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget28.FromBool(bool(m.Delete), tt.NonOptional().Field(7).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget27, fieldTarget28); err != nil {
				return err
			}
		}
	}
	var32 := (m.BatchId == uint64(0))
	if var32 {
		if err := fieldsTarget1.ZeroField("BatchId"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget30, fieldTarget31, err := fieldsTarget1.StartField("BatchId")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget31.FromUint(uint64(m.BatchId), tt.NonOptional().Field(8).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget30, fieldTarget31); err != nil {
				return err
			}
		}
	}
	var35 := (m.BatchCount == uint64(0))
	if var35 {
		if err := fieldsTarget1.ZeroField("BatchCount"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget33, fieldTarget34, err := fieldsTarget1.StartField("BatchCount")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget34.FromUint(uint64(m.BatchCount), tt.NonOptional().Field(9).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget33, fieldTarget34); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LogRecMetadata) MakeVDLTarget() vdl.Target {
	return &LogRecMetadataTarget{Value: m}
}

type LogRecMetadataTarget struct {
	Value            *LogRecMetadata
	idTarget         vdl.Uint64Target
	genTarget        vdl.Uint64Target
	recTypeTarget    vdl.ByteTarget
	objIdTarget      vdl.StringTarget
	curVersTarget    vdl.StringTarget
	parentsTarget    vdl.StringSliceTarget
	updTimeTarget    time_2.TimeTarget
	deleteTarget     vdl.BoolTarget
	batchIdTarget    vdl.Uint64Target
	batchCountTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LogRecMetadataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LogRecMetadata)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LogRecMetadataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Id":
		t.idTarget.Value = &t.Value.Id
		target, err := &t.idTarget, error(nil)
		return nil, target, err
	case "Gen":
		t.genTarget.Value = &t.Value.Gen
		target, err := &t.genTarget, error(nil)
		return nil, target, err
	case "RecType":
		t.recTypeTarget.Value = &t.Value.RecType
		target, err := &t.recTypeTarget, error(nil)
		return nil, target, err
	case "ObjId":
		t.objIdTarget.Value = &t.Value.ObjId
		target, err := &t.objIdTarget, error(nil)
		return nil, target, err
	case "CurVers":
		t.curVersTarget.Value = &t.Value.CurVers
		target, err := &t.curVersTarget, error(nil)
		return nil, target, err
	case "Parents":
		t.parentsTarget.Value = &t.Value.Parents
		target, err := &t.parentsTarget, error(nil)
		return nil, target, err
	case "UpdTime":
		t.updTimeTarget.Value = &t.Value.UpdTime
		target, err := &t.updTimeTarget, error(nil)
		return nil, target, err
	case "Delete":
		t.deleteTarget.Value = &t.Value.Delete
		target, err := &t.deleteTarget, error(nil)
		return nil, target, err
	case "BatchId":
		t.batchIdTarget.Value = &t.Value.BatchId
		target, err := &t.batchIdTarget, error(nil)
		return nil, target, err
	case "BatchCount":
		t.batchCountTarget.Value = &t.Value.BatchCount
		target, err := &t.batchCountTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata", name)
	}
}
func (t *LogRecMetadataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LogRecMetadataTarget) ZeroField(name string) error {
	switch name {
	case "Id":
		t.Value.Id = uint64(0)
		return nil
	case "Gen":
		t.Value.Gen = uint64(0)
		return nil
	case "RecType":
		t.Value.RecType = byte(0)
		return nil
	case "ObjId":
		t.Value.ObjId = ""
		return nil
	case "CurVers":
		t.Value.CurVers = ""
		return nil
	case "Parents":
		t.Value.Parents = []string(nil)
		return nil
	case "UpdTime":
		t.Value.UpdTime = func() time.Time {
			var native time.Time
			if err := vdl.Convert(&native, time_2.Time{}); err != nil {
				panic(err)
			}
			return native
		}()
		return nil
	case "Delete":
		t.Value.Delete = false
		return nil
	case "BatchId":
		t.Value.BatchId = uint64(0)
		return nil
	case "BatchCount":
		t.Value.BatchCount = uint64(0)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.LogRecMetadata", name)
	}
}
func (t *LogRecMetadataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *LogRecMetadata) VDLRead(dec vdl.Decoder) error {
	*x = LogRecMetadata{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Id":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Id, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Gen":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Gen, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "RecType":
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.RecType = byte(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "ObjId":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.ObjId, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "CurVers":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.CurVers, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Parents":
			if err = __VDLRead1_list(dec, &x.Parents); err != nil {
				return err
			}
		case "UpdTime":
			var wire time_2.Time
			if err = wire.VDLRead(dec); err != nil {
				return err
			}
			if err = time_2.TimeToNative(wire, &x.UpdTime); err != nil {
				return err
			}
		case "Delete":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Delete, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "BatchId":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.BatchId, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "BatchCount":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.BatchCount, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead1_list(dec vdl.Decoder, x *[]string) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]string, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem string
		if err = dec.StartValue(); err != nil {
			return err
		}
		if elem, err = dec.DecodeString(); err != nil {
			return err
		}
		if err = dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// LogRec represents the on-wire representation of an entire log record: its
// metadata and data. Value is the actual value of a store object.
type LogRec struct {
	Metadata LogRecMetadata
	Value    []byte
}

func (LogRec) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.LogRec"`
}) {
}

func (m *LogRec) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := true
	var5 := (m.Metadata.Id == uint64(0))
	var4 = var4 && var5
	var6 := (m.Metadata.Gen == uint64(0))
	var4 = var4 && var6
	var7 := (m.Metadata.RecType == byte(0))
	var4 = var4 && var7
	var8 := (m.Metadata.ObjId == "")
	var4 = var4 && var8
	var9 := (m.Metadata.CurVers == "")
	var4 = var4 && var9
	var var10 bool
	if len(m.Metadata.Parents) == 0 {
		var10 = true
	}
	var4 = var4 && var10
	var wireValue11 time_2.Time
	if err := time_2.TimeFromNative(&wireValue11, m.Metadata.UpdTime); err != nil {
		return fmt.Errorf("error converting m.Metadata.UpdTime to wiretype")
	}

	var12 := (wireValue11 == time_2.Time{})
	var4 = var4 && var12
	var13 := (m.Metadata.Delete == false)
	var4 = var4 && var13
	var14 := (m.Metadata.BatchId == uint64(0))
	var4 = var4 && var14
	var15 := (m.Metadata.BatchCount == uint64(0))
	var4 = var4 && var15
	if var4 {
		if err := fieldsTarget1.ZeroField("Metadata"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Metadata")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Metadata.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var18 bool
	if len(m.Value) == 0 {
		var18 = true
	}
	if var18 {
		if err := fieldsTarget1.ZeroField("Value"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget16, fieldTarget17, err := fieldsTarget1.StartField("Value")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := fieldTarget17.FromBytes([]byte(m.Value), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget16, fieldTarget17); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LogRec) MakeVDLTarget() vdl.Target {
	return &LogRecTarget{Value: m}
}

type LogRecTarget struct {
	Value          *LogRec
	metadataTarget LogRecMetadataTarget
	valueTarget    vdl.BytesTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LogRecTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LogRec)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LogRecTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Metadata":
		t.metadataTarget.Value = &t.Value.Metadata
		target, err := &t.metadataTarget, error(nil)
		return nil, target, err
	case "Value":
		t.valueTarget.Value = &t.Value.Value
		target, err := &t.valueTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.LogRec", name)
	}
}
func (t *LogRecTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LogRecTarget) ZeroField(name string) error {
	switch name {
	case "Metadata":
		t.Value.Metadata = LogRecMetadata{}
		return nil
	case "Value":
		t.Value.Value = []byte(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.LogRec", name)
	}
}
func (t *LogRecTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *LogRec) VDLRead(dec vdl.Decoder) error {
	*x = LogRec{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Metadata":
			if err = x.Metadata.VDLRead(dec); err != nil {
				return err
			}
		case "Value":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if err = dec.DecodeBytes(-1, &x.Value); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// GroupId is a globally unique syncgroup ID.
// It is a hash of the syncgroup name.
type GroupId string

func (GroupId) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.GroupId"`
}) {
}

func (m *GroupId) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromString(string((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *GroupId) MakeVDLTarget() vdl.Target {
	return &GroupIdTarget{Value: m}
}

type GroupIdTarget struct {
	Value *GroupId
	vdl.TargetBase
}

func (t *GroupIdTarget) FromString(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*GroupId)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = GroupId(src)

	return nil
}

func (x *GroupId) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeString()
	if err != nil {
		return err
	}
	*x = GroupId(tmp)
	return dec.FinishValue()
}

// Possible states for a syncgroup.
type SyncgroupStatus int

const (
	SyncgroupStatusPublishPending SyncgroupStatus = iota
	SyncgroupStatusPublishRejected
	SyncgroupStatusRunning
)

// SyncgroupStatusAll holds all labels for SyncgroupStatus.
var SyncgroupStatusAll = [...]SyncgroupStatus{SyncgroupStatusPublishPending, SyncgroupStatusPublishRejected, SyncgroupStatusRunning}

// SyncgroupStatusFromString creates a SyncgroupStatus from a string label.
func SyncgroupStatusFromString(label string) (x SyncgroupStatus, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *SyncgroupStatus) Set(label string) error {
	switch label {
	case "PublishPending", "publishpending":
		*x = SyncgroupStatusPublishPending
		return nil
	case "PublishRejected", "publishrejected":
		*x = SyncgroupStatusPublishRejected
		return nil
	case "Running", "running":
		*x = SyncgroupStatusRunning
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in interfaces.SyncgroupStatus", label)
}

// String returns the string label of x.
func (x SyncgroupStatus) String() string {
	switch x {
	case SyncgroupStatusPublishPending:
		return "PublishPending"
	case SyncgroupStatusPublishRejected:
		return "PublishRejected"
	case SyncgroupStatusRunning:
		return "Running"
	}
	return ""
}

func (SyncgroupStatus) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.SyncgroupStatus"`
	Enum struct{ PublishPending, PublishRejected, Running string }
}) {
}

func (m *SyncgroupStatus) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *SyncgroupStatus) MakeVDLTarget() vdl.Target {
	return &SyncgroupStatusTarget{Value: m}
}

type SyncgroupStatusTarget struct {
	Value *SyncgroupStatus
	vdl.TargetBase
}

func (t *SyncgroupStatusTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*SyncgroupStatus)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "PublishPending":
		*t.Value = 0
	case "PublishRejected":
		*t.Value = 1
	case "Running":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum SyncgroupStatus", src)
	}

	return nil
}

func (x *SyncgroupStatus) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err = x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

// Syncgroup contains the state of a syncgroup.
type Syncgroup struct {
	Name        string                                  // globally unique Vanadium name chosen by app
	SpecVersion string                                  // version on syncgroup spec for concurrency control
	Spec        syncbase.SyncgroupSpec                  // app-given specification
	Creator     string                                  // Creator's Vanadium name
	DbId        syncbase.Id                             // Globally unique database id
	Status      SyncgroupStatus                         // Status of the syncgroup
	Joiners     map[string]syncbase.SyncgroupMemberInfo // map of joiners to their metadata
}

func (Syncgroup) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.Syncgroup"`
}) {
}

func (m *Syncgroup) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.SpecVersion == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("SpecVersion"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("SpecVersion")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.SpecVersion), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := true
	var11 := (m.Spec.Description == "")
	var10 = var10 && var11
	var var12 bool
	if len(m.Spec.Perms) == 0 {
		var12 = true
	}
	var10 = var10 && var12
	var var13 bool
	if len(m.Spec.Prefixes) == 0 {
		var13 = true
	}
	var10 = var10 && var13
	var var14 bool
	if len(m.Spec.MountTables) == 0 {
		var14 = true
	}
	var10 = var10 && var14
	var15 := (m.Spec.IsPrivate == false)
	var10 = var10 && var15
	if var10 {
		if err := fieldsTarget1.ZeroField("Spec"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Spec")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Spec.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var18 := (m.Creator == "")
	if var18 {
		if err := fieldsTarget1.ZeroField("Creator"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget16, fieldTarget17, err := fieldsTarget1.StartField("Creator")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget17.FromString(string(m.Creator), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget16, fieldTarget17); err != nil {
				return err
			}
		}
	}
	var21 := (m.DbId == syncbase.Id{})
	if var21 {
		if err := fieldsTarget1.ZeroField("DbId"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget19, fieldTarget20, err := fieldsTarget1.StartField("DbId")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.DbId.FillVDLTarget(fieldTarget20, tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget19, fieldTarget20); err != nil {
				return err
			}
		}
	}
	var24 := (m.Status == SyncgroupStatusPublishPending)
	if var24 {
		if err := fieldsTarget1.ZeroField("Status"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget22, fieldTarget23, err := fieldsTarget1.StartField("Status")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Status.FillVDLTarget(fieldTarget23, tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget22, fieldTarget23); err != nil {
				return err
			}
		}
	}
	var var27 bool
	if len(m.Joiners) == 0 {
		var27 = true
	}
	if var27 {
		if err := fieldsTarget1.ZeroField("Joiners"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget25, fieldTarget26, err := fieldsTarget1.StartField("Joiners")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget28, err := fieldTarget26.StartMap(tt.NonOptional().Field(6).Type, len(m.Joiners))
			if err != nil {
				return err
			}
			for key30, value32 := range m.Joiners {
				keyTarget29, err := mapTarget28.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget29.FromString(string(key30), tt.NonOptional().Field(6).Type.Key()); err != nil {
					return err
				}
				valueTarget31, err := mapTarget28.FinishKeyStartField(keyTarget29)
				if err != nil {
					return err
				}

				if err := value32.FillVDLTarget(valueTarget31, tt.NonOptional().Field(6).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget28.FinishField(keyTarget29, valueTarget31); err != nil {
					return err
				}
			}
			if err := fieldTarget26.FinishMap(mapTarget28); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget25, fieldTarget26); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Syncgroup) MakeVDLTarget() vdl.Target {
	return &SyncgroupTarget{Value: m}
}

type SyncgroupTarget struct {
	Value             *Syncgroup
	nameTarget        vdl.StringTarget
	specVersionTarget vdl.StringTarget
	specTarget        syncbase.SyncgroupSpecTarget
	creatorTarget     vdl.StringTarget
	dbIdTarget        syncbase.IdTarget
	statusTarget      SyncgroupStatusTarget
	joinersTarget     __VDLTarget1_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SyncgroupTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Syncgroup)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *SyncgroupTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "SpecVersion":
		t.specVersionTarget.Value = &t.Value.SpecVersion
		target, err := &t.specVersionTarget, error(nil)
		return nil, target, err
	case "Spec":
		t.specTarget.Value = &t.Value.Spec
		target, err := &t.specTarget, error(nil)
		return nil, target, err
	case "Creator":
		t.creatorTarget.Value = &t.Value.Creator
		target, err := &t.creatorTarget, error(nil)
		return nil, target, err
	case "DbId":
		t.dbIdTarget.Value = &t.Value.DbId
		target, err := &t.dbIdTarget, error(nil)
		return nil, target, err
	case "Status":
		t.statusTarget.Value = &t.Value.Status
		target, err := &t.statusTarget, error(nil)
		return nil, target, err
	case "Joiners":
		t.joinersTarget.Value = &t.Value.Joiners
		target, err := &t.joinersTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.Syncgroup", name)
	}
}
func (t *SyncgroupTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SyncgroupTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "SpecVersion":
		t.Value.SpecVersion = ""
		return nil
	case "Spec":
		t.Value.Spec = syncbase.SyncgroupSpec{}
		return nil
	case "Creator":
		t.Value.Creator = ""
		return nil
	case "DbId":
		t.Value.DbId = syncbase.Id{}
		return nil
	case "Status":
		t.Value.Status = SyncgroupStatusPublishPending
		return nil
	case "Joiners":
		t.Value.Joiners = map[string]syncbase.SyncgroupMemberInfo(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.Syncgroup", name)
	}
}
func (t *SyncgroupTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[string]syncbase.SyncgroupMemberInfo
type __VDLTarget1_map struct {
	Value      *map[string]syncbase.SyncgroupMemberInfo
	currKey    string
	currElem   syncbase.SyncgroupMemberInfo
	keyTarget  vdl.StringTarget
	elemTarget syncbase.SyncgroupMemberInfoTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget1_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]syncbase.SyncgroupMemberInfo)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]syncbase.SyncgroupMemberInfo)
	return t, nil
}
func (t *__VDLTarget1_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = syncbase.SyncgroupMemberInfo{}
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget1_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *Syncgroup) VDLRead(dec vdl.Decoder) error {
	*x = Syncgroup{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "SpecVersion":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.SpecVersion, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Spec":
			if err = x.Spec.VDLRead(dec); err != nil {
				return err
			}
		case "Creator":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Creator, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "DbId":
			if err = x.DbId.VDLRead(dec); err != nil {
				return err
			}
		case "Status":
			if err = x.Status.VDLRead(dec); err != nil {
				return err
			}
		case "Joiners":
			if err = __VDLRead2_map(dec, &x.Joiners); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead2_map(dec vdl.Decoder, x *map[string]syncbase.SyncgroupMemberInfo) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string]syncbase.SyncgroupMemberInfo
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]syncbase.SyncgroupMemberInfo, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem syncbase.SyncgroupMemberInfo
		{
			if err = elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string]syncbase.SyncgroupMemberInfo)
		}
		tmpMap[key] = elem
	}
}

// SgDeltaReq contains the initiator's genvectors for the syncgroups it is
// interested in within a database when requesting deltas for those syncgroups.
type SgDeltaReq struct {
	DbId syncbase.Id
	Gvs  Knowledge // Contains a genvector per syncgroup.
}

func (SgDeltaReq) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.SgDeltaReq"`
}) {
}

func (m *SgDeltaReq) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.DbId == syncbase.Id{})
	if var4 {
		if err := fieldsTarget1.ZeroField("DbId"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("DbId")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.DbId.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.Gvs) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("Gvs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Gvs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Gvs.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SgDeltaReq) MakeVDLTarget() vdl.Target {
	return &SgDeltaReqTarget{Value: m}
}

type SgDeltaReqTarget struct {
	Value      *SgDeltaReq
	dbIdTarget syncbase.IdTarget
	gvsTarget  KnowledgeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SgDeltaReqTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*SgDeltaReq)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *SgDeltaReqTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "DbId":
		t.dbIdTarget.Value = &t.Value.DbId
		target, err := &t.dbIdTarget, error(nil)
		return nil, target, err
	case "Gvs":
		t.gvsTarget.Value = &t.Value.Gvs
		target, err := &t.gvsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.SgDeltaReq", name)
	}
}
func (t *SgDeltaReqTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SgDeltaReqTarget) ZeroField(name string) error {
	switch name {
	case "DbId":
		t.Value.DbId = syncbase.Id{}
		return nil
	case "Gvs":
		t.Value.Gvs = Knowledge(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.SgDeltaReq", name)
	}
}
func (t *SgDeltaReqTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *SgDeltaReq) VDLRead(dec vdl.Decoder) error {
	*x = SgDeltaReq{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "DbId":
			if err = x.DbId.VDLRead(dec); err != nil {
				return err
			}
		case "Gvs":
			if err = x.Gvs.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// DataDeltaReq contains the initiator's genvectors and the set of syncgroups it
// is interested in within a database when requesting deltas for that database.
type DataDeltaReq struct {
	DbId  syncbase.Id
	SgIds map[GroupId]struct{}
	Gvs   Knowledge
}

func (DataDeltaReq) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.DataDeltaReq"`
}) {
}

func (m *DataDeltaReq) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.DbId == syncbase.Id{})
	if var4 {
		if err := fieldsTarget1.ZeroField("DbId"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("DbId")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.DbId.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.SgIds) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("SgIds"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("SgIds")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget8, err := fieldTarget6.StartSet(tt.NonOptional().Field(1).Type, len(m.SgIds))
			if err != nil {
				return err
			}
			for key10 := range m.SgIds {
				keyTarget9, err := setTarget8.StartKey()
				if err != nil {
					return err
				}

				if err := key10.FillVDLTarget(keyTarget9, tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				if err := setTarget8.FinishKey(keyTarget9); err != nil {
					return err
				}
			}
			if err := fieldTarget6.FinishSet(setTarget8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var var13 bool
	if len(m.Gvs) == 0 {
		var13 = true
	}
	if var13 {
		if err := fieldsTarget1.ZeroField("Gvs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Gvs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Gvs.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *DataDeltaReq) MakeVDLTarget() vdl.Target {
	return &DataDeltaReqTarget{Value: m}
}

type DataDeltaReqTarget struct {
	Value       *DataDeltaReq
	dbIdTarget  syncbase.IdTarget
	sgIdsTarget __VDLTarget2_set
	gvsTarget   KnowledgeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DataDeltaReqTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*DataDeltaReq)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *DataDeltaReqTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "DbId":
		t.dbIdTarget.Value = &t.Value.DbId
		target, err := &t.dbIdTarget, error(nil)
		return nil, target, err
	case "SgIds":
		t.sgIdsTarget.Value = &t.Value.SgIds
		target, err := &t.sgIdsTarget, error(nil)
		return nil, target, err
	case "Gvs":
		t.gvsTarget.Value = &t.Value.Gvs
		target, err := &t.gvsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.DataDeltaReq", name)
	}
}
func (t *DataDeltaReqTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *DataDeltaReqTarget) ZeroField(name string) error {
	switch name {
	case "DbId":
		t.Value.DbId = syncbase.Id{}
		return nil
	case "SgIds":
		t.Value.SgIds = map[GroupId]struct{}(nil)
		return nil
	case "Gvs":
		t.Value.Gvs = Knowledge(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.DataDeltaReq", name)
	}
}
func (t *DataDeltaReqTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[GroupId]struct{}
type __VDLTarget2_set struct {
	Value     *map[GroupId]struct{}
	currKey   GroupId
	keyTarget GroupIdTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget2_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[GroupId]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[GroupId]struct{})
	return t, nil
}
func (t *__VDLTarget2_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = GroupId("")
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget2_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *DataDeltaReq) VDLRead(dec vdl.Decoder) error {
	*x = DataDeltaReq{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "DbId":
			if err = x.DbId.VDLRead(dec); err != nil {
				return err
			}
		case "SgIds":
			if err = __VDLRead3_set(dec, &x.SgIds); err != nil {
				return err
			}
		case "Gvs":
			if err = x.Gvs.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead3_set(dec vdl.Decoder, x *map[GroupId]struct{}) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[GroupId]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[GroupId]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key GroupId
		{
			if err = key.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[GroupId]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

type (
	// DeltaReq represents any single field of the DeltaReq union type.
	//
	// DeltaReq contains a request to sync either data or syncgroup metadata for a
	// Database.
	DeltaReq interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the DeltaReq union type.
		__VDLReflect(__DeltaReqReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// DeltaReqSgs represents field Sgs of the DeltaReq union type.
	DeltaReqSgs struct{ Value SgDeltaReq }
	// DeltaReqData represents field Data of the DeltaReq union type.
	DeltaReqData struct{ Value DataDeltaReq }
	// __DeltaReqReflect describes the DeltaReq union type.
	__DeltaReqReflect struct {
		Name               string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.DeltaReq"`
		Type               DeltaReq
		UnionTargetFactory deltaReqTargetFactory
		Union              struct {
			Sgs  DeltaReqSgs
			Data DeltaReqData
		}
	}
)

func (x DeltaReqSgs) Index() int                     { return 0 }
func (x DeltaReqSgs) Interface() interface{}         { return x.Value }
func (x DeltaReqSgs) Name() string                   { return "Sgs" }
func (x DeltaReqSgs) __VDLReflect(__DeltaReqReflect) {}

func (m DeltaReqSgs) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Sgs")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m DeltaReqSgs) MakeVDLTarget() vdl.Target {
	return nil
}

func (x DeltaReqData) Index() int                     { return 1 }
func (x DeltaReqData) Interface() interface{}         { return x.Value }
func (x DeltaReqData) Name() string                   { return "Data" }
func (x DeltaReqData) __VDLReflect(__DeltaReqReflect) {}

func (m DeltaReqData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Data")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m DeltaReqData) MakeVDLTarget() vdl.Target {
	return nil
}

type DeltaReqTarget struct {
	Value     *DeltaReq
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DeltaReqTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*DeltaReq)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *DeltaReqTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "Sgs":
		val := SgDeltaReq{}
		return nil, &SgDeltaReqTarget{Value: &val}, nil
	case "Data":
		val := DataDeltaReq{}
		return nil, &DataDeltaReqTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/x/ref/services/syncbase/server/interfaces.DeltaReq", name)
	}
}
func (t *DeltaReqTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "Sgs":
		*t.Value = DeltaReqSgs{*(fieldTarget.(*SgDeltaReqTarget)).Value}
	case "Data":
		*t.Value = DeltaReqData{*(fieldTarget.(*DataDeltaReqTarget)).Value}
	}
	return nil
}
func (t *DeltaReqTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type deltaReqTargetFactory struct{}

func (t deltaReqTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*DeltaReq); ok {
		return &DeltaReqTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *DeltaReq", union)
}

func VDLReadDeltaReq(dec vdl.Decoder, x *DeltaReq) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "Sgs":
		var field DeltaReqSgs
		if err = field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "Data":
		var field DeltaReqData
		if err = field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type (
	// DeltaResp represents any single field of the DeltaResp union type.
	//
	// DeltaResp contains the responder's genvectors or the missing log records
	// returned in response to an initiator's request for deltas for a Database.
	DeltaResp interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the DeltaResp union type.
		__VDLReflect(__DeltaRespReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// DeltaRespRec represents field Rec of the DeltaResp union type.
	DeltaRespRec struct{ Value LogRec }
	// DeltaRespGvs represents field Gvs of the DeltaResp union type.
	DeltaRespGvs struct{ Value Knowledge }
	// __DeltaRespReflect describes the DeltaResp union type.
	__DeltaRespReflect struct {
		Name               string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.DeltaResp"`
		Type               DeltaResp
		UnionTargetFactory deltaRespTargetFactory
		Union              struct {
			Rec DeltaRespRec
			Gvs DeltaRespGvs
		}
	}
)

func (x DeltaRespRec) Index() int                      { return 0 }
func (x DeltaRespRec) Interface() interface{}          { return x.Value }
func (x DeltaRespRec) Name() string                    { return "Rec" }
func (x DeltaRespRec) __VDLReflect(__DeltaRespReflect) {}

func (m DeltaRespRec) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rec")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m DeltaRespRec) MakeVDLTarget() vdl.Target {
	return nil
}

func (x DeltaRespGvs) Index() int                      { return 1 }
func (x DeltaRespGvs) Interface() interface{}          { return x.Value }
func (x DeltaRespGvs) Name() string                    { return "Gvs" }
func (x DeltaRespGvs) __VDLReflect(__DeltaRespReflect) {}

func (m DeltaRespGvs) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Gvs")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m DeltaRespGvs) MakeVDLTarget() vdl.Target {
	return nil
}

type DeltaRespTarget struct {
	Value     *DeltaResp
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DeltaRespTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*DeltaResp)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *DeltaRespTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "Rec":
		val := LogRec{}
		return nil, &LogRecTarget{Value: &val}, nil
	case "Gvs":
		val := Knowledge(nil)
		return nil, &KnowledgeTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/x/ref/services/syncbase/server/interfaces.DeltaResp", name)
	}
}
func (t *DeltaRespTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "Rec":
		*t.Value = DeltaRespRec{*(fieldTarget.(*LogRecTarget)).Value}
	case "Gvs":
		*t.Value = DeltaRespGvs{*(fieldTarget.(*KnowledgeTarget)).Value}
	}
	return nil
}
func (t *DeltaRespTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type deltaRespTargetFactory struct{}

func (t deltaRespTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*DeltaResp); ok {
		return &DeltaRespTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *DeltaResp", union)
}

func VDLReadDeltaResp(dec vdl.Decoder, x *DeltaResp) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "Rec":
		var field DeltaRespRec
		if err = field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "Gvs":
		var field DeltaRespGvs
		if err = field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

// A SgPriority represents data used to decide whether to transfer blob ownership
// between two devices.
type SgPriority struct {
	DevType    int32     // device type (BlobDevTypeServer, BlobDevTypeNormal, BlobDevTypeLeaf)
	Distance   float32   // mean number of hops from a server-quality member of the syncgroup
	ServerTime time.Time // when data from a server-quality member reached this device
}

func (SgPriority) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.SgPriority"`
}) {
}

func (m *SgPriority) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.DevType == int32(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("DevType"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("DevType")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromInt(int64(m.DevType), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Distance == float32(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Distance"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Distance")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromFloat(float64(m.Distance), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var wireValue8 time_2.Time
	if err := time_2.TimeFromNative(&wireValue8, m.ServerTime); err != nil {
		return err
	}

	var11 := (wireValue8 == time_2.Time{})
	if var11 {
		if err := fieldsTarget1.ZeroField("ServerTime"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("ServerTime")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue8.FillVDLTarget(fieldTarget10, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SgPriority) MakeVDLTarget() vdl.Target {
	return &SgPriorityTarget{Value: m}
}

type SgPriorityTarget struct {
	Value            *SgPriority
	devTypeTarget    vdl.Int32Target
	distanceTarget   vdl.Float32Target
	serverTimeTarget time_2.TimeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SgPriorityTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*SgPriority)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *SgPriorityTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "DevType":
		t.devTypeTarget.Value = &t.Value.DevType
		target, err := &t.devTypeTarget, error(nil)
		return nil, target, err
	case "Distance":
		t.distanceTarget.Value = &t.Value.Distance
		target, err := &t.distanceTarget, error(nil)
		return nil, target, err
	case "ServerTime":
		t.serverTimeTarget.Value = &t.Value.ServerTime
		target, err := &t.serverTimeTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.SgPriority", name)
	}
}
func (t *SgPriorityTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SgPriorityTarget) ZeroField(name string) error {
	switch name {
	case "DevType":
		t.Value.DevType = int32(0)
		return nil
	case "Distance":
		t.Value.Distance = float32(0)
		return nil
	case "ServerTime":
		t.Value.ServerTime = func() time.Time {
			var native time.Time
			if err := vdl.Convert(&native, time_2.Time{}); err != nil {
				panic(err)
			}
			return native
		}()
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.SgPriority", name)
	}
}
func (t *SgPriorityTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *SgPriority) VDLRead(dec vdl.Decoder) error {
	*x = SgPriority{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "DevType":
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.DevType = int32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Distance":
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			x.Distance = float32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "ServerTime":
			var wire time_2.Time
			if err = wire.VDLRead(dec); err != nil {
				return err
			}
			if err = time_2.TimeToNative(wire, &x.ServerTime); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// A SgPriorities maps syncgroup IDs to SgPriority structures.  It is sent and
// received in GetDeltas calls to allow the participants to assess who has
// higher priorities for keeping blobs.
type SgPriorities map[GroupId]SgPriority

func (SgPriorities) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.SgPriorities"`
}) {
}

func (m *SgPriorities) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SgPriorities) MakeVDLTarget() vdl.Target {
	return &SgPrioritiesTarget{Value: m}
}

type SgPrioritiesTarget struct {
	Value      *SgPriorities
	currKey    GroupId
	currElem   SgPriority
	keyTarget  GroupIdTarget
	elemTarget SgPriorityTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SgPrioritiesTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*SgPriorities)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SgPriorities)
	return t, nil
}
func (t *SgPrioritiesTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = GroupId("")
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SgPrioritiesTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().(SgPriority)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *SgPrioritiesTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SgPrioritiesTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *SgPriorities) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap SgPriorities
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SgPriorities, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key GroupId
		{
			if err = key.VDLRead(dec); err != nil {
				return err
			}
		}
		var elem SgPriority
		{
			if err = elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SgPriorities)
		}
		tmpMap[key] = elem
	}
}

// DeltaFinalResp contains the data returned at the end of a GetDeltas call.
type DeltaFinalResp struct {
	SgPriorities SgPriorities
}

func (DeltaFinalResp) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.DeltaFinalResp"`
}) {
}

func (m *DeltaFinalResp) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.SgPriorities) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("SgPriorities"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("SgPriorities")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.SgPriorities.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *DeltaFinalResp) MakeVDLTarget() vdl.Target {
	return &DeltaFinalRespTarget{Value: m}
}

type DeltaFinalRespTarget struct {
	Value              *DeltaFinalResp
	sgPrioritiesTarget SgPrioritiesTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DeltaFinalRespTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*DeltaFinalResp)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *DeltaFinalRespTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "SgPriorities":
		t.sgPrioritiesTarget.Value = &t.Value.SgPriorities
		target, err := &t.sgPrioritiesTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.DeltaFinalResp", name)
	}
}
func (t *DeltaFinalRespTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *DeltaFinalRespTarget) ZeroField(name string) error {
	switch name {
	case "SgPriorities":
		t.Value.SgPriorities = SgPriorities(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.DeltaFinalResp", name)
	}
}
func (t *DeltaFinalRespTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *DeltaFinalResp) VDLRead(dec vdl.Decoder) error {
	*x = DeltaFinalResp{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "SgPriorities":
			if err = x.SgPriorities.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// ChunkHash contains the hash of a chunk that is part of a blob's recipe.
type ChunkHash struct {
	Hash []byte
}

func (ChunkHash) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.ChunkHash"`
}) {
}

func (m *ChunkHash) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.Hash) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("Hash"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Hash")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := fieldTarget3.FromBytes([]byte(m.Hash), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ChunkHash) MakeVDLTarget() vdl.Target {
	return &ChunkHashTarget{Value: m}
}

type ChunkHashTarget struct {
	Value      *ChunkHash
	hashTarget vdl.BytesTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ChunkHashTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ChunkHash)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ChunkHashTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Hash":
		t.hashTarget.Value = &t.Value.Hash
		target, err := &t.hashTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.ChunkHash", name)
	}
}
func (t *ChunkHashTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ChunkHashTarget) ZeroField(name string) error {
	switch name {
	case "Hash":
		t.Value.Hash = []byte(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.ChunkHash", name)
	}
}
func (t *ChunkHashTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *ChunkHash) VDLRead(dec vdl.Decoder) error {
	*x = ChunkHash{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Hash":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if err = dec.DecodeBytes(-1, &x.Hash); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// ChunkData contains the data of a chunk.
type ChunkData struct {
	Data []byte
}

func (ChunkData) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.ChunkData"`
}) {
}

func (m *ChunkData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.Data) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("Data"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Data")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := fieldTarget3.FromBytes([]byte(m.Data), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ChunkData) MakeVDLTarget() vdl.Target {
	return &ChunkDataTarget{Value: m}
}

type ChunkDataTarget struct {
	Value      *ChunkData
	dataTarget vdl.BytesTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ChunkDataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ChunkData)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ChunkDataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Data":
		t.dataTarget.Value = &t.Value.Data
		target, err := &t.dataTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.ChunkData", name)
	}
}
func (t *ChunkDataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ChunkDataTarget) ZeroField(name string) error {
	switch name {
	case "Data":
		t.Value.Data = []byte(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.ChunkData", name)
	}
}
func (t *ChunkDataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *ChunkData) VDLRead(dec vdl.Decoder) error {
	*x = ChunkData{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Data":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if err = dec.DecodeBytes(-1, &x.Data); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// TimeReq contains the send timestamp from the requester.
type TimeReq struct {
	SendTs time.Time
}

func (TimeReq) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.TimeReq"`
}) {
}

func (m *TimeReq) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var wireValue2 time_2.Time
	if err := time_2.TimeFromNative(&wireValue2, m.SendTs); err != nil {
		return err
	}

	var5 := (wireValue2 == time_2.Time{})
	if var5 {
		if err := fieldsTarget1.ZeroField("SendTs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget3, fieldTarget4, err := fieldsTarget1.StartField("SendTs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue2.FillVDLTarget(fieldTarget4, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget3, fieldTarget4); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TimeReq) MakeVDLTarget() vdl.Target {
	return &TimeReqTarget{Value: m}
}

type TimeReqTarget struct {
	Value        *TimeReq
	sendTsTarget time_2.TimeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TimeReqTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*TimeReq)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *TimeReqTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "SendTs":
		t.sendTsTarget.Value = &t.Value.SendTs
		target, err := &t.sendTsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.TimeReq", name)
	}
}
func (t *TimeReqTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TimeReqTarget) ZeroField(name string) error {
	switch name {
	case "SendTs":
		t.Value.SendTs = func() time.Time {
			var native time.Time
			if err := vdl.Convert(&native, time_2.Time{}); err != nil {
				panic(err)
			}
			return native
		}()
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.TimeReq", name)
	}
}
func (t *TimeReqTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *TimeReq) VDLRead(dec vdl.Decoder) error {
	*x = TimeReq{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "SendTs":
			var wire time_2.Time
			if err = wire.VDLRead(dec); err != nil {
				return err
			}
			if err = time_2.TimeToNative(wire, &x.SendTs); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// TimeResp contains information needed by the requester to estimate the
// difference between the two vclocks and to decide whether to incorporate the
// peer's vclock data.
type TimeResp struct {
	OrigTs time.Time // when we sent request
	RecvTs time.Time // when peer received request
	SendTs time.Time // when peer sent response
	// NTP server timestamp from the most recent NTP sync, or zero value if none.
	// Note, the NTP sync may have been performed by some peer device.
	LastNtpTs time.Time
	// Number of reboots since last NTP sync, accumulated across all hops of p2p
	// clock sync.
	NumReboots uint16
	// Number of sync hops between peer's device and its source of LastNtpTs.
	NumHops uint16
}

func (TimeResp) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.TimeResp"`
}) {
}

func (m *TimeResp) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var wireValue2 time_2.Time
	if err := time_2.TimeFromNative(&wireValue2, m.OrigTs); err != nil {
		return err
	}

	var5 := (wireValue2 == time_2.Time{})
	if var5 {
		if err := fieldsTarget1.ZeroField("OrigTs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget3, fieldTarget4, err := fieldsTarget1.StartField("OrigTs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue2.FillVDLTarget(fieldTarget4, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget3, fieldTarget4); err != nil {
				return err
			}
		}
	}
	var wireValue6 time_2.Time
	if err := time_2.TimeFromNative(&wireValue6, m.RecvTs); err != nil {
		return err
	}

	var9 := (wireValue6 == time_2.Time{})
	if var9 {
		if err := fieldsTarget1.ZeroField("RecvTs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("RecvTs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue6.FillVDLTarget(fieldTarget8, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
				return err
			}
		}
	}
	var wireValue10 time_2.Time
	if err := time_2.TimeFromNative(&wireValue10, m.SendTs); err != nil {
		return err
	}

	var13 := (wireValue10 == time_2.Time{})
	if var13 {
		if err := fieldsTarget1.ZeroField("SendTs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("SendTs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue10.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var wireValue14 time_2.Time
	if err := time_2.TimeFromNative(&wireValue14, m.LastNtpTs); err != nil {
		return err
	}

	var17 := (wireValue14 == time_2.Time{})
	if var17 {
		if err := fieldsTarget1.ZeroField("LastNtpTs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget15, fieldTarget16, err := fieldsTarget1.StartField("LastNtpTs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue14.FillVDLTarget(fieldTarget16, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget15, fieldTarget16); err != nil {
				return err
			}
		}
	}
	var20 := (m.NumReboots == uint16(0))
	if var20 {
		if err := fieldsTarget1.ZeroField("NumReboots"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("NumReboots")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget19.FromUint(uint64(m.NumReboots), tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
				return err
			}
		}
	}
	var23 := (m.NumHops == uint16(0))
	if var23 {
		if err := fieldsTarget1.ZeroField("NumHops"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget21, fieldTarget22, err := fieldsTarget1.StartField("NumHops")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget22.FromUint(uint64(m.NumHops), tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget21, fieldTarget22); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TimeResp) MakeVDLTarget() vdl.Target {
	return &TimeRespTarget{Value: m}
}

type TimeRespTarget struct {
	Value            *TimeResp
	origTsTarget     time_2.TimeTarget
	recvTsTarget     time_2.TimeTarget
	sendTsTarget     time_2.TimeTarget
	lastNtpTsTarget  time_2.TimeTarget
	numRebootsTarget vdl.Uint16Target
	numHopsTarget    vdl.Uint16Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TimeRespTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*TimeResp)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *TimeRespTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "OrigTs":
		t.origTsTarget.Value = &t.Value.OrigTs
		target, err := &t.origTsTarget, error(nil)
		return nil, target, err
	case "RecvTs":
		t.recvTsTarget.Value = &t.Value.RecvTs
		target, err := &t.recvTsTarget, error(nil)
		return nil, target, err
	case "SendTs":
		t.sendTsTarget.Value = &t.Value.SendTs
		target, err := &t.sendTsTarget, error(nil)
		return nil, target, err
	case "LastNtpTs":
		t.lastNtpTsTarget.Value = &t.Value.LastNtpTs
		target, err := &t.lastNtpTsTarget, error(nil)
		return nil, target, err
	case "NumReboots":
		t.numRebootsTarget.Value = &t.Value.NumReboots
		target, err := &t.numRebootsTarget, error(nil)
		return nil, target, err
	case "NumHops":
		t.numHopsTarget.Value = &t.Value.NumHops
		target, err := &t.numHopsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.TimeResp", name)
	}
}
func (t *TimeRespTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TimeRespTarget) ZeroField(name string) error {
	switch name {
	case "OrigTs":
		t.Value.OrigTs = func() time.Time {
			var native time.Time
			if err := vdl.Convert(&native, time_2.Time{}); err != nil {
				panic(err)
			}
			return native
		}()
		return nil
	case "RecvTs":
		t.Value.RecvTs = func() time.Time {
			var native time.Time
			if err := vdl.Convert(&native, time_2.Time{}); err != nil {
				panic(err)
			}
			return native
		}()
		return nil
	case "SendTs":
		t.Value.SendTs = func() time.Time {
			var native time.Time
			if err := vdl.Convert(&native, time_2.Time{}); err != nil {
				panic(err)
			}
			return native
		}()
		return nil
	case "LastNtpTs":
		t.Value.LastNtpTs = func() time.Time {
			var native time.Time
			if err := vdl.Convert(&native, time_2.Time{}); err != nil {
				panic(err)
			}
			return native
		}()
		return nil
	case "NumReboots":
		t.Value.NumReboots = uint16(0)
		return nil
	case "NumHops":
		t.Value.NumHops = uint16(0)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.TimeResp", name)
	}
}
func (t *TimeRespTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *TimeResp) VDLRead(dec vdl.Decoder) error {
	*x = TimeResp{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "OrigTs":
			var wire time_2.Time
			if err = wire.VDLRead(dec); err != nil {
				return err
			}
			if err = time_2.TimeToNative(wire, &x.OrigTs); err != nil {
				return err
			}
		case "RecvTs":
			var wire time_2.Time
			if err = wire.VDLRead(dec); err != nil {
				return err
			}
			if err = time_2.TimeToNative(wire, &x.RecvTs); err != nil {
				return err
			}
		case "SendTs":
			var wire time_2.Time
			if err = wire.VDLRead(dec); err != nil {
				return err
			}
			if err = time_2.TimeToNative(wire, &x.SendTs); err != nil {
				return err
			}
		case "LastNtpTs":
			var wire time_2.Time
			if err = wire.VDLRead(dec); err != nil {
				return err
			}
			if err = time_2.TimeToNative(wire, &x.LastNtpTs); err != nil {
				return err
			}
		case "NumReboots":
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			x.NumReboots = uint16(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "NumHops":
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			x.NumHops = uint16(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// A BlobSharesBySyncgroup maps syncgroup IDs to integer share numbers that a
// syncbase instance may have for a blob.
type BlobSharesBySyncgroup map[GroupId]int32

func (BlobSharesBySyncgroup) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.BlobSharesBySyncgroup"`
}) {
}

func (m *BlobSharesBySyncgroup) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromInt(int64(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BlobSharesBySyncgroup) MakeVDLTarget() vdl.Target {
	return &BlobSharesBySyncgroupTarget{Value: m}
}

type BlobSharesBySyncgroupTarget struct {
	Value      *BlobSharesBySyncgroup
	currKey    GroupId
	currElem   int32
	keyTarget  GroupIdTarget
	elemTarget vdl.Int32Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *BlobSharesBySyncgroupTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*BlobSharesBySyncgroup)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(BlobSharesBySyncgroup)
	return t, nil
}
func (t *BlobSharesBySyncgroupTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = GroupId("")
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *BlobSharesBySyncgroupTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = int32(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *BlobSharesBySyncgroupTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *BlobSharesBySyncgroupTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *BlobSharesBySyncgroup) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap BlobSharesBySyncgroup
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(BlobSharesBySyncgroup, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key GroupId
		{
			if err = key.VDLRead(dec); err != nil {
				return err
			}
		}
		var elem int32
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			elem = int32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(BlobSharesBySyncgroup)
		}
		tmpMap[key] = elem
	}
}

// A LocationData is the information known about a particular location in a Signpost.
// TODO(m3b): Include mount table information to allow the location to be found.
type LocationData struct {
	WhenSeen time.Time // most recent time when blob thought to have been at location
	IsProxy  bool      // whether the location is a likely proxy to another syncgroup
	IsServer bool      // whether the location is a server that may be revealed outside its syncgroup
}

func (LocationData) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.LocationData"`
}) {
}

func (m *LocationData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var wireValue2 time_2.Time
	if err := time_2.TimeFromNative(&wireValue2, m.WhenSeen); err != nil {
		return err
	}

	var5 := (wireValue2 == time_2.Time{})
	if var5 {
		if err := fieldsTarget1.ZeroField("WhenSeen"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget3, fieldTarget4, err := fieldsTarget1.StartField("WhenSeen")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue2.FillVDLTarget(fieldTarget4, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget3, fieldTarget4); err != nil {
				return err
			}
		}
	}
	var8 := (m.IsProxy == false)
	if var8 {
		if err := fieldsTarget1.ZeroField("IsProxy"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("IsProxy")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget7.FromBool(bool(m.IsProxy), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
				return err
			}
		}
	}
	var11 := (m.IsServer == false)
	if var11 {
		if err := fieldsTarget1.ZeroField("IsServer"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("IsServer")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget10.FromBool(bool(m.IsServer), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LocationData) MakeVDLTarget() vdl.Target {
	return &LocationDataTarget{Value: m}
}

type LocationDataTarget struct {
	Value          *LocationData
	whenSeenTarget time_2.TimeTarget
	isProxyTarget  vdl.BoolTarget
	isServerTarget vdl.BoolTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LocationDataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LocationData)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LocationDataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "WhenSeen":
		t.whenSeenTarget.Value = &t.Value.WhenSeen
		target, err := &t.whenSeenTarget, error(nil)
		return nil, target, err
	case "IsProxy":
		t.isProxyTarget.Value = &t.Value.IsProxy
		target, err := &t.isProxyTarget, error(nil)
		return nil, target, err
	case "IsServer":
		t.isServerTarget.Value = &t.Value.IsServer
		target, err := &t.isServerTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.LocationData", name)
	}
}
func (t *LocationDataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LocationDataTarget) ZeroField(name string) error {
	switch name {
	case "WhenSeen":
		t.Value.WhenSeen = func() time.Time {
			var native time.Time
			if err := vdl.Convert(&native, time_2.Time{}); err != nil {
				panic(err)
			}
			return native
		}()
		return nil
	case "IsProxy":
		t.Value.IsProxy = false
		return nil
	case "IsServer":
		t.Value.IsServer = false
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.LocationData", name)
	}
}
func (t *LocationDataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *LocationData) VDLRead(dec vdl.Decoder) error {
	*x = LocationData{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "WhenSeen":
			var wire time_2.Time
			if err = wire.VDLRead(dec); err != nil {
				return err
			}
			if err = time_2.TimeToNative(wire, &x.WhenSeen); err != nil {
				return err
			}
		case "IsProxy":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.IsProxy, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "IsServer":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.IsServer, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// A PeerToLocationDataMap is a map from syncbase peer names to LocationData structures.
type PeerToLocationDataMap map[string]LocationData

func (PeerToLocationDataMap) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.PeerToLocationDataMap"`
}) {
}

func (m *PeerToLocationDataMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *PeerToLocationDataMap) MakeVDLTarget() vdl.Target {
	return &PeerToLocationDataMapTarget{Value: m}
}

type PeerToLocationDataMapTarget struct {
	Value      *PeerToLocationDataMap
	currKey    string
	currElem   LocationData
	keyTarget  vdl.StringTarget
	elemTarget LocationDataTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *PeerToLocationDataMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*PeerToLocationDataMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(PeerToLocationDataMap)
	return t, nil
}
func (t *PeerToLocationDataMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *PeerToLocationDataMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().(LocationData)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *PeerToLocationDataMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *PeerToLocationDataMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *PeerToLocationDataMap) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap PeerToLocationDataMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(PeerToLocationDataMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem LocationData
		{
			if err = elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(PeerToLocationDataMap)
		}
		tmpMap[key] = elem
	}
}

// A Signpost is a hint to syncbase of the device on which a blob may be found.
// It represents the data known about a blob even when the blob itself is not
// present on the device.
type Signpost struct {
	Locations PeerToLocationDataMap // Maps name of syncbase that probably has the blob to a LocationData
	SgIds     map[GroupId]struct{}  // SyncGroups through which the BlobRef was learned.
}

func (Signpost) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/syncbase/server/interfaces.Signpost"`
}) {
}

func (m *Signpost) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.Locations) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("Locations"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Locations")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Locations.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.SgIds) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("SgIds"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("SgIds")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget8, err := fieldTarget6.StartSet(tt.NonOptional().Field(1).Type, len(m.SgIds))
			if err != nil {
				return err
			}
			for key10 := range m.SgIds {
				keyTarget9, err := setTarget8.StartKey()
				if err != nil {
					return err
				}

				if err := key10.FillVDLTarget(keyTarget9, tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				if err := setTarget8.FinishKey(keyTarget9); err != nil {
					return err
				}
			}
			if err := fieldTarget6.FinishSet(setTarget8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Signpost) MakeVDLTarget() vdl.Target {
	return &SignpostTarget{Value: m}
}

type SignpostTarget struct {
	Value           *Signpost
	locationsTarget PeerToLocationDataMapTarget
	sgIdsTarget     __VDLTarget2_set
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SignpostTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Signpost)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *SignpostTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Locations":
		t.locationsTarget.Value = &t.Value.Locations
		target, err := &t.locationsTarget, error(nil)
		return nil, target, err
	case "SgIds":
		t.sgIdsTarget.Value = &t.Value.SgIds
		target, err := &t.sgIdsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.Signpost", name)
	}
}
func (t *SignpostTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SignpostTarget) ZeroField(name string) error {
	switch name {
	case "Locations":
		t.Value.Locations = PeerToLocationDataMap(nil)
		return nil
	case "SgIds":
		t.Value.SgIds = map[GroupId]struct{}(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/x/ref/services/syncbase/server/interfaces.Signpost", name)
	}
}
func (t *SignpostTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *Signpost) VDLRead(dec vdl.Decoder) error {
	*x = Signpost{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Locations":
			if err = x.Locations.VDLRead(dec); err != nil {
				return err
			}
		case "SgIds":
			if err = __VDLRead3_set(dec, &x.SgIds); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

//////////////////////////////////////////////////
// Const definitions

const NoGroupId = GroupId("")

// NodeRec type log record adds a new node in the dag.
const NodeRec = byte(0)

// LinkRec type log record adds a new link in the dag. Link records are
// added when a conflict is resolved by picking the local or the remote
// version as the resolution of a conflict, instead of creating a new
// version.
const LinkRec = byte(1)

//////////////////////////////////////////////////
// Error definitions
var (
	ErrDupSyncgroupPublish = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.DupSyncgroupPublish", verror.NoRetry, "{1:}{2:} duplicate publish on syncgroup: {3}")
	ErrConnFail            = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.ConnFail", verror.NoRetry, "{1:}{2:} connection to peer failed{:_}")
	ErrBrokenCrConnection  = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.BrokenCrConnection", verror.NoRetry, "{1:}{2:} CrConnection stream to client does not exist or is broken")
	ErrDbOffline           = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.DbOffline", verror.NoRetry, "{1:}{2:} database {3} is offline and cannot be synced{:_}")
	ErrGetTimeFailed       = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.GetTimeFailed", verror.NoRetry, "{1:}{2:} GetTime failed{:_}")
	ErrNotAdmin            = verror.Register("v.io/x/ref/services/syncbase/server/interfaces.NotAdmin", verror.NoRetry, "{1:}{2:} not an admin of the syncgroup")
)

// NewErrDupSyncgroupPublish returns an error with the ErrDupSyncgroupPublish ID.
func NewErrDupSyncgroupPublish(ctx *context.T, name string) error {
	return verror.New(ErrDupSyncgroupPublish, ctx, name)
}

// NewErrConnFail returns an error with the ErrConnFail ID.
func NewErrConnFail(ctx *context.T) error {
	return verror.New(ErrConnFail, ctx)
}

// NewErrBrokenCrConnection returns an error with the ErrBrokenCrConnection ID.
func NewErrBrokenCrConnection(ctx *context.T) error {
	return verror.New(ErrBrokenCrConnection, ctx)
}

// NewErrDbOffline returns an error with the ErrDbOffline ID.
func NewErrDbOffline(ctx *context.T, dbId syncbase.Id) error {
	return verror.New(ErrDbOffline, ctx, dbId)
}

// NewErrGetTimeFailed returns an error with the ErrGetTimeFailed ID.
func NewErrGetTimeFailed(ctx *context.T) error {
	return verror.New(ErrGetTimeFailed, ctx)
}

// NewErrNotAdmin returns an error with the ErrNotAdmin ID.
func NewErrNotAdmin(ctx *context.T) error {
	return verror.New(ErrNotAdmin, ctx)
}

//////////////////////////////////////////////////
// Interface definitions

// SyncClientMethods is the client interface
// containing Sync methods.
//
// Sync defines methods for data exchange between Syncbases.
// TODO(hpucha): Flesh this out further.
type SyncClientMethods interface {
	// GetTime returns metadata related to the Syncbase virtual clock, including
	// system clock values, last NTP timestamp, num reboots, etc.
	GetTime(_ *context.T, req TimeReq, initiator string, _ ...rpc.CallOpt) (TimeResp, error)
	// GetDeltas returns the responder's current generation vectors and all
	// the missing log records when compared to the initiator's generation
	// vectors for one Database for either syncgroup metadata or data.
	// The final result (in DeltaFinalResp) currently includes the
	// syncgroup priorities for blob ownership for the server.
	GetDeltas(_ *context.T, req DeltaReq, initiator string, _ ...rpc.CallOpt) (SyncGetDeltasClientCall, error)
	// PublishSyncgroup is invoked on the syncgroup name (typically served
	// by a "central" peer) to publish the syncgroup.  It takes the name of
	// Syncbase doing the publishing (the publisher) and returns the name
	// of the Syncbase where the syncgroup is published (the publishee).
	// This allows the publisher and the publishee to learn of each other.
	// When a syncgroup is published, the publishee is given the syncgroup
	// metadata, its current version at the publisher, and the current
	// syncgroup generation vector.  The generation vector serves as a
	// checkpoint at the time of publishing.  The publishing proceeds
	// asynchronously, and the publishee learns the syncgroup history
	// through the routine p2p sync process and determines when it has
	// caught up to the level of knowledge at the time of publishing using
	// the checkpointed generation vector.  Until that point, the publishee
	// locally deems the syncgroup to be in a pending state and does not
	// mutate it.  Thus it locally rejects syncgroup joins or updates to
	// its spec until it is caught up on the syncgroup history.
	PublishSyncgroup(_ *context.T, publisher string, sg Syncgroup, version string, genvec GenVector, _ ...rpc.CallOpt) (string, error)
	// JoinSyncgroupAtAdmin is invoked by a prospective syncgroup member's
	// Syncbase on a syncgroup admin. It checks whether the requestor is
	// allowed to join the named syncgroup, and if so, adds the requestor to
	// the syncgroup.  It returns a copy of the updated syncgroup metadata,
	// its version, and the syncgroup generation vector at the time of the
	// join.  Similar to the PublishSyncgroup scenario, the joiner at that
	// point does not have the syncgroup history and locally deems it to be
	// in a pending state and does not mutate it.  This means it rejects
	// local updates to the syncgroup spec or, if it were also an admin on
	// the syncgroup, it would reject syncgroup joins until it is caught up
	// on the syncgroup history through p2p sync.
	JoinSyncgroupAtAdmin(_ *context.T, sgName string, joinerName string, myInfo syncbase.SyncgroupMemberInfo, _ ...rpc.CallOpt) (sg Syncgroup, version string, genvec GenVector, _ error)
	// HaveBlob verifies that the peer has the requested blob, and if
	// present, returns its size.  Otherwise, it returns -1, and the location
	// hints (the Signpost) that the peer has for the blob, filtered to
	// include only data the caller is permitted to see:
	// + Device D reveals a syncgroup SG to the caller C iff
	//   - D is in SG, and
	//   - SG is in the Signpost, and
	//   - at least one of:
	//     - SG is not private, or
	//     - C has permission to join SG.
	// + Device D reveals a location hint L to caller C iff
	//   there is a syncgroup SG such that
	//   - D is in SG, and
	//   - SG is in the Signpost, and
	//   - L is in SG, and
	//   - at least one of:
	//     - SG is not private, or
	//     - C has permission to join SG, or
	//     - L is a blob server in SG.
	HaveBlob(_ *context.T, br syncbase.BlobRef, _ ...rpc.CallOpt) (size int64, signpost Signpost, _ error)
	// FetchBlob fetches the requested blob.
	// It returns a number of blob ownership shares that the server hopes
	// the client will accept using the AcceptedBlobOwnership() call.
	FetchBlob(_ *context.T, br syncbase.BlobRef, mySgPriorities SgPriorities, _ ...rpc.CallOpt) (SyncFetchBlobClientCall, error)
	// Methods for incremental blob transfer. The transfer starts with the
	// receiver making a FetchBlobRecipe call to the sender for a given
	// BlobRef. The sender, in turn, sends the chunk hashes of all the
	// chunks that make up the requested blob (blob recipe). The receiver
	// looks up the chunk hashes in its local blob store, and identifies the
	// missing ones. The receiver then fetches the missing chunks using a
	// FetchChunks call from the sender. Finally, the receiver finishes the
	// blob fetch by combining the chunks obtained over the network with the
	// already available local chunks as per the blob recipe.
	// callerName is the syncbase Id of the caller, expressed as a string.
	// FetchBlobRecipe returns a number of blob ownership shares that the
	// server hopes the client will accept for each syncgroup using the
	// AcceptedBlobOwnership() call.
	FetchBlobRecipe(_ *context.T, br syncbase.BlobRef, callerName string, mySgPriorities SgPriorities, _ ...rpc.CallOpt) (SyncFetchBlobRecipeClientCall, error)
	FetchChunks(*context.T, ...rpc.CallOpt) (SyncFetchChunksClientCall, error)
	// RequestTakeBlob indicates that the caller wishes the server to take
	// some blob ownership shares for various syncgroups for the specified blob.
	// If the server chooses to act on the request, it may call FetchBlob/FetchBlobRecipe,
	// and ultimately AcceptedBlobOwnership().
	// callerName is the syncbase Id of the caller, expressed as a string.
	RequestTakeBlob(_ *context.T, br syncbase.BlobRef, callerName string, shares BlobSharesBySyncgroup, _ ...rpc.CallOpt) error
	// AcceptedBlobOwnership tells the server that the client callerName (a
	// syncbase Id expressed as a string) has accepted blob ownership of a
	// specified number of shares for blob br.  The server may decrement
	// its share count by up to this number.  It is safe for the server to
	// decrement its share count by fewer than the number of shares another
	// device has taken responsibility for, but unsafe to decrement it by
	// more than that that number.  It returns a hint as to whether the
	// server is likely to keep the blob itself, plus its syncbase Id
	// expressed as a string.
	AcceptedBlobOwnership(_ *context.T, br syncbase.BlobRef, callerName string, shares BlobSharesBySyncgroup, _ ...rpc.CallOpt) (serverName string, keepingBlob bool, _ error)
}

// SyncClientStub adds universal methods to SyncClientMethods.
type SyncClientStub interface {
	SyncClientMethods
	rpc.UniversalServiceMethods
}

// SyncClient returns a client stub for Sync.
func SyncClient(name string) SyncClientStub {
	return implSyncClientStub{name}
}

type implSyncClientStub struct {
	name string
}

func (c implSyncClientStub) GetTime(ctx *context.T, i0 TimeReq, i1 string, opts ...rpc.CallOpt) (o0 TimeResp, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "GetTime", []interface{}{i0, i1}, []interface{}{&o0}, opts...)
	return
}

func (c implSyncClientStub) GetDeltas(ctx *context.T, i0 DeltaReq, i1 string, opts ...rpc.CallOpt) (ocall SyncGetDeltasClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "GetDeltas", []interface{}{i0, i1}, opts...); err != nil {
		return
	}
	ocall = &implSyncGetDeltasClientCall{ClientCall: call}
	return
}

func (c implSyncClientStub) PublishSyncgroup(ctx *context.T, i0 string, i1 Syncgroup, i2 string, i3 GenVector, opts ...rpc.CallOpt) (o0 string, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "PublishSyncgroup", []interface{}{i0, i1, i2, i3}, []interface{}{&o0}, opts...)
	return
}

func (c implSyncClientStub) JoinSyncgroupAtAdmin(ctx *context.T, i0 string, i1 string, i2 syncbase.SyncgroupMemberInfo, opts ...rpc.CallOpt) (o0 Syncgroup, o1 string, o2 GenVector, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "JoinSyncgroupAtAdmin", []interface{}{i0, i1, i2}, []interface{}{&o0, &o1, &o2}, opts...)
	return
}

func (c implSyncClientStub) HaveBlob(ctx *context.T, i0 syncbase.BlobRef, opts ...rpc.CallOpt) (o0 int64, o1 Signpost, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "HaveBlob", []interface{}{i0}, []interface{}{&o0, &o1}, opts...)
	return
}

func (c implSyncClientStub) FetchBlob(ctx *context.T, i0 syncbase.BlobRef, i1 SgPriorities, opts ...rpc.CallOpt) (ocall SyncFetchBlobClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "FetchBlob", []interface{}{i0, i1}, opts...); err != nil {
		return
	}
	ocall = &implSyncFetchBlobClientCall{ClientCall: call}
	return
}

func (c implSyncClientStub) FetchBlobRecipe(ctx *context.T, i0 syncbase.BlobRef, i1 string, i2 SgPriorities, opts ...rpc.CallOpt) (ocall SyncFetchBlobRecipeClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "FetchBlobRecipe", []interface{}{i0, i1, i2}, opts...); err != nil {
		return
	}
	ocall = &implSyncFetchBlobRecipeClientCall{ClientCall: call}
	return
}

func (c implSyncClientStub) FetchChunks(ctx *context.T, opts ...rpc.CallOpt) (ocall SyncFetchChunksClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "FetchChunks", nil, opts...); err != nil {
		return
	}
	ocall = &implSyncFetchChunksClientCall{ClientCall: call}
	return
}

func (c implSyncClientStub) RequestTakeBlob(ctx *context.T, i0 syncbase.BlobRef, i1 string, i2 BlobSharesBySyncgroup, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "RequestTakeBlob", []interface{}{i0, i1, i2}, nil, opts...)
	return
}

func (c implSyncClientStub) AcceptedBlobOwnership(ctx *context.T, i0 syncbase.BlobRef, i1 string, i2 BlobSharesBySyncgroup, opts ...rpc.CallOpt) (o0 string, o1 bool, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "AcceptedBlobOwnership", []interface{}{i0, i1, i2}, []interface{}{&o0, &o1}, opts...)
	return
}

// SyncGetDeltasClientStream is the client stream for Sync.GetDeltas.
type SyncGetDeltasClientStream interface {
	// RecvStream returns the receiver side of the Sync.GetDeltas client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() DeltaResp
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// SyncGetDeltasClientCall represents the call returned from Sync.GetDeltas.
type SyncGetDeltasClientCall interface {
	SyncGetDeltasClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() (DeltaFinalResp, error)
}

type implSyncGetDeltasClientCall struct {
	rpc.ClientCall
	valRecv DeltaResp
	errRecv error
}

func (c *implSyncGetDeltasClientCall) RecvStream() interface {
	Advance() bool
	Value() DeltaResp
	Err() error
} {
	return implSyncGetDeltasClientCallRecv{c}
}

type implSyncGetDeltasClientCallRecv struct {
	c *implSyncGetDeltasClientCall
}

func (c implSyncGetDeltasClientCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implSyncGetDeltasClientCallRecv) Value() DeltaResp {
	return c.c.valRecv
}
func (c implSyncGetDeltasClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implSyncGetDeltasClientCall) Finish() (o0 DeltaFinalResp, err error) {
	err = c.ClientCall.Finish(&o0)
	return
}

// SyncFetchBlobClientStream is the client stream for Sync.FetchBlob.
type SyncFetchBlobClientStream interface {
	// RecvStream returns the receiver side of the Sync.FetchBlob client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() []byte
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// SyncFetchBlobClientCall represents the call returned from Sync.FetchBlob.
type SyncFetchBlobClientCall interface {
	SyncFetchBlobClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() (shares BlobSharesBySyncgroup, _ error)
}

type implSyncFetchBlobClientCall struct {
	rpc.ClientCall
	valRecv []byte
	errRecv error
}

func (c *implSyncFetchBlobClientCall) RecvStream() interface {
	Advance() bool
	Value() []byte
	Err() error
} {
	return implSyncFetchBlobClientCallRecv{c}
}

type implSyncFetchBlobClientCallRecv struct {
	c *implSyncFetchBlobClientCall
}

func (c implSyncFetchBlobClientCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implSyncFetchBlobClientCallRecv) Value() []byte {
	return c.c.valRecv
}
func (c implSyncFetchBlobClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implSyncFetchBlobClientCall) Finish() (o0 BlobSharesBySyncgroup, err error) {
	err = c.ClientCall.Finish(&o0)
	return
}

// SyncFetchBlobRecipeClientStream is the client stream for Sync.FetchBlobRecipe.
type SyncFetchBlobRecipeClientStream interface {
	// RecvStream returns the receiver side of the Sync.FetchBlobRecipe client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() ChunkHash
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// SyncFetchBlobRecipeClientCall represents the call returned from Sync.FetchBlobRecipe.
type SyncFetchBlobRecipeClientCall interface {
	SyncFetchBlobRecipeClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() (shares BlobSharesBySyncgroup, _ error)
}

type implSyncFetchBlobRecipeClientCall struct {
	rpc.ClientCall
	valRecv ChunkHash
	errRecv error
}

func (c *implSyncFetchBlobRecipeClientCall) RecvStream() interface {
	Advance() bool
	Value() ChunkHash
	Err() error
} {
	return implSyncFetchBlobRecipeClientCallRecv{c}
}

type implSyncFetchBlobRecipeClientCallRecv struct {
	c *implSyncFetchBlobRecipeClientCall
}

func (c implSyncFetchBlobRecipeClientCallRecv) Advance() bool {
	c.c.valRecv = ChunkHash{}
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implSyncFetchBlobRecipeClientCallRecv) Value() ChunkHash {
	return c.c.valRecv
}
func (c implSyncFetchBlobRecipeClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implSyncFetchBlobRecipeClientCall) Finish() (o0 BlobSharesBySyncgroup, err error) {
	err = c.ClientCall.Finish(&o0)
	return
}

// SyncFetchChunksClientStream is the client stream for Sync.FetchChunks.
type SyncFetchChunksClientStream interface {
	// RecvStream returns the receiver side of the Sync.FetchChunks client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() ChunkData
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the Sync.FetchChunks client stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors
		// encountered while sending, or if Send is called after Close or
		// the stream has been canceled.  Blocks if there is no buffer
		// space; will unblock when buffer space is available or after
		// the stream has been canceled.
		Send(item ChunkHash) error
		// Close indicates to the server that no more items will be sent;
		// server Recv calls will receive io.EOF after all sent items.
		// This is an optional call - e.g. a client might call Close if it
		// needs to continue receiving items from the server after it's
		// done sending.  Returns errors encountered while closing, or if
		// Close is called after the stream has been canceled.  Like Send,
		// blocks if there is no buffer space available.
		Close() error
	}
}

// SyncFetchChunksClientCall represents the call returned from Sync.FetchChunks.
type SyncFetchChunksClientCall interface {
	SyncFetchChunksClientStream
	// Finish performs the equivalent of SendStream().Close, then blocks until
	// the server is done, and returns the positional return values for the call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implSyncFetchChunksClientCall struct {
	rpc.ClientCall
	valRecv ChunkData
	errRecv error
}

func (c *implSyncFetchChunksClientCall) RecvStream() interface {
	Advance() bool
	Value() ChunkData
	Err() error
} {
	return implSyncFetchChunksClientCallRecv{c}
}

type implSyncFetchChunksClientCallRecv struct {
	c *implSyncFetchChunksClientCall
}

func (c implSyncFetchChunksClientCallRecv) Advance() bool {
	c.c.valRecv = ChunkData{}
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implSyncFetchChunksClientCallRecv) Value() ChunkData {
	return c.c.valRecv
}
func (c implSyncFetchChunksClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implSyncFetchChunksClientCall) SendStream() interface {
	Send(item ChunkHash) error
	Close() error
} {
	return implSyncFetchChunksClientCallSend{c}
}

type implSyncFetchChunksClientCallSend struct {
	c *implSyncFetchChunksClientCall
}

func (c implSyncFetchChunksClientCallSend) Send(item ChunkHash) error {
	return c.c.Send(item)
}
func (c implSyncFetchChunksClientCallSend) Close() error {
	return c.c.CloseSend()
}
func (c *implSyncFetchChunksClientCall) Finish() (err error) {
	err = c.ClientCall.Finish()
	return
}

// SyncServerMethods is the interface a server writer
// implements for Sync.
//
// Sync defines methods for data exchange between Syncbases.
// TODO(hpucha): Flesh this out further.
type SyncServerMethods interface {
	// GetTime returns metadata related to the Syncbase virtual clock, including
	// system clock values, last NTP timestamp, num reboots, etc.
	GetTime(_ *context.T, _ rpc.ServerCall, req TimeReq, initiator string) (TimeResp, error)
	// GetDeltas returns the responder's current generation vectors and all
	// the missing log records when compared to the initiator's generation
	// vectors for one Database for either syncgroup metadata or data.
	// The final result (in DeltaFinalResp) currently includes the
	// syncgroup priorities for blob ownership for the server.
	GetDeltas(_ *context.T, _ SyncGetDeltasServerCall, req DeltaReq, initiator string) (DeltaFinalResp, error)
	// PublishSyncgroup is invoked on the syncgroup name (typically served
	// by a "central" peer) to publish the syncgroup.  It takes the name of
	// Syncbase doing the publishing (the publisher) and returns the name
	// of the Syncbase where the syncgroup is published (the publishee).
	// This allows the publisher and the publishee to learn of each other.
	// When a syncgroup is published, the publishee is given the syncgroup
	// metadata, its current version at the publisher, and the current
	// syncgroup generation vector.  The generation vector serves as a
	// checkpoint at the time of publishing.  The publishing proceeds
	// asynchronously, and the publishee learns the syncgroup history
	// through the routine p2p sync process and determines when it has
	// caught up to the level of knowledge at the time of publishing using
	// the checkpointed generation vector.  Until that point, the publishee
	// locally deems the syncgroup to be in a pending state and does not
	// mutate it.  Thus it locally rejects syncgroup joins or updates to
	// its spec until it is caught up on the syncgroup history.
	PublishSyncgroup(_ *context.T, _ rpc.ServerCall, publisher string, sg Syncgroup, version string, genvec GenVector) (string, error)
	// JoinSyncgroupAtAdmin is invoked by a prospective syncgroup member's
	// Syncbase on a syncgroup admin. It checks whether the requestor is
	// allowed to join the named syncgroup, and if so, adds the requestor to
	// the syncgroup.  It returns a copy of the updated syncgroup metadata,
	// its version, and the syncgroup generation vector at the time of the
	// join.  Similar to the PublishSyncgroup scenario, the joiner at that
	// point does not have the syncgroup history and locally deems it to be
	// in a pending state and does not mutate it.  This means it rejects
	// local updates to the syncgroup spec or, if it were also an admin on
	// the syncgroup, it would reject syncgroup joins until it is caught up
	// on the syncgroup history through p2p sync.
	JoinSyncgroupAtAdmin(_ *context.T, _ rpc.ServerCall, sgName string, joinerName string, myInfo syncbase.SyncgroupMemberInfo) (sg Syncgroup, version string, genvec GenVector, _ error)
	// HaveBlob verifies that the peer has the requested blob, and if
	// present, returns its size.  Otherwise, it returns -1, and the location
	// hints (the Signpost) that the peer has for the blob, filtered to
	// include only data the caller is permitted to see:
	// + Device D reveals a syncgroup SG to the caller C iff
	//   - D is in SG, and
	//   - SG is in the Signpost, and
	//   - at least one of:
	//     - SG is not private, or
	//     - C has permission to join SG.
	// + Device D reveals a location hint L to caller C iff
	//   there is a syncgroup SG such that
	//   - D is in SG, and
	//   - SG is in the Signpost, and
	//   - L is in SG, and
	//   - at least one of:
	//     - SG is not private, or
	//     - C has permission to join SG, or
	//     - L is a blob server in SG.
	HaveBlob(_ *context.T, _ rpc.ServerCall, br syncbase.BlobRef) (size int64, signpost Signpost, _ error)
	// FetchBlob fetches the requested blob.
	// It returns a number of blob ownership shares that the server hopes
	// the client will accept using the AcceptedBlobOwnership() call.
	FetchBlob(_ *context.T, _ SyncFetchBlobServerCall, br syncbase.BlobRef, mySgPriorities SgPriorities) (shares BlobSharesBySyncgroup, _ error)
	// Methods for incremental blob transfer. The transfer starts with the
	// receiver making a FetchBlobRecipe call to the sender for a given
	// BlobRef. The sender, in turn, sends the chunk hashes of all the
	// chunks that make up the requested blob (blob recipe). The receiver
	// looks up the chunk hashes in its local blob store, and identifies the
	// missing ones. The receiver then fetches the missing chunks using a
	// FetchChunks call from the sender. Finally, the receiver finishes the
	// blob fetch by combining the chunks obtained over the network with the
	// already available local chunks as per the blob recipe.
	// callerName is the syncbase Id of the caller, expressed as a string.
	// FetchBlobRecipe returns a number of blob ownership shares that the
	// server hopes the client will accept for each syncgroup using the
	// AcceptedBlobOwnership() call.
	FetchBlobRecipe(_ *context.T, _ SyncFetchBlobRecipeServerCall, br syncbase.BlobRef, callerName string, mySgPriorities SgPriorities) (shares BlobSharesBySyncgroup, _ error)
	FetchChunks(*context.T, SyncFetchChunksServerCall) error
	// RequestTakeBlob indicates that the caller wishes the server to take
	// some blob ownership shares for various syncgroups for the specified blob.
	// If the server chooses to act on the request, it may call FetchBlob/FetchBlobRecipe,
	// and ultimately AcceptedBlobOwnership().
	// callerName is the syncbase Id of the caller, expressed as a string.
	RequestTakeBlob(_ *context.T, _ rpc.ServerCall, br syncbase.BlobRef, callerName string, shares BlobSharesBySyncgroup) error
	// AcceptedBlobOwnership tells the server that the client callerName (a
	// syncbase Id expressed as a string) has accepted blob ownership of a
	// specified number of shares for blob br.  The server may decrement
	// its share count by up to this number.  It is safe for the server to
	// decrement its share count by fewer than the number of shares another
	// device has taken responsibility for, but unsafe to decrement it by
	// more than that that number.  It returns a hint as to whether the
	// server is likely to keep the blob itself, plus its syncbase Id
	// expressed as a string.
	AcceptedBlobOwnership(_ *context.T, _ rpc.ServerCall, br syncbase.BlobRef, callerName string, shares BlobSharesBySyncgroup) (serverName string, keepingBlob bool, _ error)
}

// SyncServerStubMethods is the server interface containing
// Sync methods, as expected by rpc.Server.
// The only difference between this interface and SyncServerMethods
// is the streaming methods.
type SyncServerStubMethods interface {
	// GetTime returns metadata related to the Syncbase virtual clock, including
	// system clock values, last NTP timestamp, num reboots, etc.
	GetTime(_ *context.T, _ rpc.ServerCall, req TimeReq, initiator string) (TimeResp, error)
	// GetDeltas returns the responder's current generation vectors and all
	// the missing log records when compared to the initiator's generation
	// vectors for one Database for either syncgroup metadata or data.
	// The final result (in DeltaFinalResp) currently includes the
	// syncgroup priorities for blob ownership for the server.
	GetDeltas(_ *context.T, _ *SyncGetDeltasServerCallStub, req DeltaReq, initiator string) (DeltaFinalResp, error)
	// PublishSyncgroup is invoked on the syncgroup name (typically served
	// by a "central" peer) to publish the syncgroup.  It takes the name of
	// Syncbase doing the publishing (the publisher) and returns the name
	// of the Syncbase where the syncgroup is published (the publishee).
	// This allows the publisher and the publishee to learn of each other.
	// When a syncgroup is published, the publishee is given the syncgroup
	// metadata, its current version at the publisher, and the current
	// syncgroup generation vector.  The generation vector serves as a
	// checkpoint at the time of publishing.  The publishing proceeds
	// asynchronously, and the publishee learns the syncgroup history
	// through the routine p2p sync process and determines when it has
	// caught up to the level of knowledge at the time of publishing using
	// the checkpointed generation vector.  Until that point, the publishee
	// locally deems the syncgroup to be in a pending state and does not
	// mutate it.  Thus it locally rejects syncgroup joins or updates to
	// its spec until it is caught up on the syncgroup history.
	PublishSyncgroup(_ *context.T, _ rpc.ServerCall, publisher string, sg Syncgroup, version string, genvec GenVector) (string, error)
	// JoinSyncgroupAtAdmin is invoked by a prospective syncgroup member's
	// Syncbase on a syncgroup admin. It checks whether the requestor is
	// allowed to join the named syncgroup, and if so, adds the requestor to
	// the syncgroup.  It returns a copy of the updated syncgroup metadata,
	// its version, and the syncgroup generation vector at the time of the
	// join.  Similar to the PublishSyncgroup scenario, the joiner at that
	// point does not have the syncgroup history and locally deems it to be
	// in a pending state and does not mutate it.  This means it rejects
	// local updates to the syncgroup spec or, if it were also an admin on
	// the syncgroup, it would reject syncgroup joins until it is caught up
	// on the syncgroup history through p2p sync.
	JoinSyncgroupAtAdmin(_ *context.T, _ rpc.ServerCall, sgName string, joinerName string, myInfo syncbase.SyncgroupMemberInfo) (sg Syncgroup, version string, genvec GenVector, _ error)
	// HaveBlob verifies that the peer has the requested blob, and if
	// present, returns its size.  Otherwise, it returns -1, and the location
	// hints (the Signpost) that the peer has for the blob, filtered to
	// include only data the caller is permitted to see:
	// + Device D reveals a syncgroup SG to the caller C iff
	//   - D is in SG, and
	//   - SG is in the Signpost, and
	//   - at least one of:
	//     - SG is not private, or
	//     - C has permission to join SG.
	// + Device D reveals a location hint L to caller C iff
	//   there is a syncgroup SG such that
	//   - D is in SG, and
	//   - SG is in the Signpost, and
	//   - L is in SG, and
	//   - at least one of:
	//     - SG is not private, or
	//     - C has permission to join SG, or
	//     - L is a blob server in SG.
	HaveBlob(_ *context.T, _ rpc.ServerCall, br syncbase.BlobRef) (size int64, signpost Signpost, _ error)
	// FetchBlob fetches the requested blob.
	// It returns a number of blob ownership shares that the server hopes
	// the client will accept using the AcceptedBlobOwnership() call.
	FetchBlob(_ *context.T, _ *SyncFetchBlobServerCallStub, br syncbase.BlobRef, mySgPriorities SgPriorities) (shares BlobSharesBySyncgroup, _ error)
	// Methods for incremental blob transfer. The transfer starts with the
	// receiver making a FetchBlobRecipe call to the sender for a given
	// BlobRef. The sender, in turn, sends the chunk hashes of all the
	// chunks that make up the requested blob (blob recipe). The receiver
	// looks up the chunk hashes in its local blob store, and identifies the
	// missing ones. The receiver then fetches the missing chunks using a
	// FetchChunks call from the sender. Finally, the receiver finishes the
	// blob fetch by combining the chunks obtained over the network with the
	// already available local chunks as per the blob recipe.
	// callerName is the syncbase Id of the caller, expressed as a string.
	// FetchBlobRecipe returns a number of blob ownership shares that the
	// server hopes the client will accept for each syncgroup using the
	// AcceptedBlobOwnership() call.
	FetchBlobRecipe(_ *context.T, _ *SyncFetchBlobRecipeServerCallStub, br syncbase.BlobRef, callerName string, mySgPriorities SgPriorities) (shares BlobSharesBySyncgroup, _ error)
	FetchChunks(*context.T, *SyncFetchChunksServerCallStub) error
	// RequestTakeBlob indicates that the caller wishes the server to take
	// some blob ownership shares for various syncgroups for the specified blob.
	// If the server chooses to act on the request, it may call FetchBlob/FetchBlobRecipe,
	// and ultimately AcceptedBlobOwnership().
	// callerName is the syncbase Id of the caller, expressed as a string.
	RequestTakeBlob(_ *context.T, _ rpc.ServerCall, br syncbase.BlobRef, callerName string, shares BlobSharesBySyncgroup) error
	// AcceptedBlobOwnership tells the server that the client callerName (a
	// syncbase Id expressed as a string) has accepted blob ownership of a
	// specified number of shares for blob br.  The server may decrement
	// its share count by up to this number.  It is safe for the server to
	// decrement its share count by fewer than the number of shares another
	// device has taken responsibility for, but unsafe to decrement it by
	// more than that that number.  It returns a hint as to whether the
	// server is likely to keep the blob itself, plus its syncbase Id
	// expressed as a string.
	AcceptedBlobOwnership(_ *context.T, _ rpc.ServerCall, br syncbase.BlobRef, callerName string, shares BlobSharesBySyncgroup) (serverName string, keepingBlob bool, _ error)
}

// SyncServerStub adds universal methods to SyncServerStubMethods.
type SyncServerStub interface {
	SyncServerStubMethods
	// Describe the Sync interfaces.
	Describe__() []rpc.InterfaceDesc
}

// SyncServer returns a server stub for Sync.
// It converts an implementation of SyncServerMethods into
// an object that may be used by rpc.Server.
func SyncServer(impl SyncServerMethods) SyncServerStub {
	stub := implSyncServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implSyncServerStub struct {
	impl SyncServerMethods
	gs   *rpc.GlobState
}

func (s implSyncServerStub) GetTime(ctx *context.T, call rpc.ServerCall, i0 TimeReq, i1 string) (TimeResp, error) {
	return s.impl.GetTime(ctx, call, i0, i1)
}

func (s implSyncServerStub) GetDeltas(ctx *context.T, call *SyncGetDeltasServerCallStub, i0 DeltaReq, i1 string) (DeltaFinalResp, error) {
	return s.impl.GetDeltas(ctx, call, i0, i1)
}

func (s implSyncServerStub) PublishSyncgroup(ctx *context.T, call rpc.ServerCall, i0 string, i1 Syncgroup, i2 string, i3 GenVector) (string, error) {
	return s.impl.PublishSyncgroup(ctx, call, i0, i1, i2, i3)
}

func (s implSyncServerStub) JoinSyncgroupAtAdmin(ctx *context.T, call rpc.ServerCall, i0 string, i1 string, i2 syncbase.SyncgroupMemberInfo) (Syncgroup, string, GenVector, error) {
	return s.impl.JoinSyncgroupAtAdmin(ctx, call, i0, i1, i2)
}

func (s implSyncServerStub) HaveBlob(ctx *context.T, call rpc.ServerCall, i0 syncbase.BlobRef) (int64, Signpost, error) {
	return s.impl.HaveBlob(ctx, call, i0)
}

func (s implSyncServerStub) FetchBlob(ctx *context.T, call *SyncFetchBlobServerCallStub, i0 syncbase.BlobRef, i1 SgPriorities) (BlobSharesBySyncgroup, error) {
	return s.impl.FetchBlob(ctx, call, i0, i1)
}

func (s implSyncServerStub) FetchBlobRecipe(ctx *context.T, call *SyncFetchBlobRecipeServerCallStub, i0 syncbase.BlobRef, i1 string, i2 SgPriorities) (BlobSharesBySyncgroup, error) {
	return s.impl.FetchBlobRecipe(ctx, call, i0, i1, i2)
}

func (s implSyncServerStub) FetchChunks(ctx *context.T, call *SyncFetchChunksServerCallStub) error {
	return s.impl.FetchChunks(ctx, call)
}

func (s implSyncServerStub) RequestTakeBlob(ctx *context.T, call rpc.ServerCall, i0 syncbase.BlobRef, i1 string, i2 BlobSharesBySyncgroup) error {
	return s.impl.RequestTakeBlob(ctx, call, i0, i1, i2)
}

func (s implSyncServerStub) AcceptedBlobOwnership(ctx *context.T, call rpc.ServerCall, i0 syncbase.BlobRef, i1 string, i2 BlobSharesBySyncgroup) (string, bool, error) {
	return s.impl.AcceptedBlobOwnership(ctx, call, i0, i1, i2)
}

func (s implSyncServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implSyncServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{SyncDesc}
}

// SyncDesc describes the Sync interface.
var SyncDesc rpc.InterfaceDesc = descSync

// descSync hides the desc to keep godoc clean.
var descSync = rpc.InterfaceDesc{
	Name:    "Sync",
	PkgPath: "v.io/x/ref/services/syncbase/server/interfaces",
	Doc:     "// Sync defines methods for data exchange between Syncbases.\n// TODO(hpucha): Flesh this out further.",
	Methods: []rpc.MethodDesc{
		{
			Name: "GetTime",
			Doc:  "// GetTime returns metadata related to the Syncbase virtual clock, including\n// system clock values, last NTP timestamp, num reboots, etc.",
			InArgs: []rpc.ArgDesc{
				{"req", ``},       // TimeReq
				{"initiator", ``}, // string
			},
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // TimeResp
			},
		},
		{
			Name: "GetDeltas",
			Doc:  "// GetDeltas returns the responder's current generation vectors and all\n// the missing log records when compared to the initiator's generation\n// vectors for one Database for either syncgroup metadata or data.\n// The final result (in DeltaFinalResp) currently includes the\n// syncgroup priorities for blob ownership for the server.",
			InArgs: []rpc.ArgDesc{
				{"req", ``},       // DeltaReq
				{"initiator", ``}, // string
			},
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // DeltaFinalResp
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Read"))},
		},
		{
			Name: "PublishSyncgroup",
			Doc:  "// PublishSyncgroup is invoked on the syncgroup name (typically served\n// by a \"central\" peer) to publish the syncgroup.  It takes the name of\n// Syncbase doing the publishing (the publisher) and returns the name\n// of the Syncbase where the syncgroup is published (the publishee).\n// This allows the publisher and the publishee to learn of each other.\n// When a syncgroup is published, the publishee is given the syncgroup\n// metadata, its current version at the publisher, and the current\n// syncgroup generation vector.  The generation vector serves as a\n// checkpoint at the time of publishing.  The publishing proceeds\n// asynchronously, and the publishee learns the syncgroup history\n// through the routine p2p sync process and determines when it has\n// caught up to the level of knowledge at the time of publishing using\n// the checkpointed generation vector.  Until that point, the publishee\n// locally deems the syncgroup to be in a pending state and does not\n// mutate it.  Thus it locally rejects syncgroup joins or updates to\n// its spec until it is caught up on the syncgroup history.",
			InArgs: []rpc.ArgDesc{
				{"publisher", ``}, // string
				{"sg", ``},        // Syncgroup
				{"version", ``},   // string
				{"genvec", ``},    // GenVector
			},
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Write"))},
		},
		{
			Name: "JoinSyncgroupAtAdmin",
			Doc:  "// JoinSyncgroupAtAdmin is invoked by a prospective syncgroup member's\n// Syncbase on a syncgroup admin. It checks whether the requestor is\n// allowed to join the named syncgroup, and if so, adds the requestor to\n// the syncgroup.  It returns a copy of the updated syncgroup metadata,\n// its version, and the syncgroup generation vector at the time of the\n// join.  Similar to the PublishSyncgroup scenario, the joiner at that\n// point does not have the syncgroup history and locally deems it to be\n// in a pending state and does not mutate it.  This means it rejects\n// local updates to the syncgroup spec or, if it were also an admin on\n// the syncgroup, it would reject syncgroup joins until it is caught up\n// on the syncgroup history through p2p sync.",
			InArgs: []rpc.ArgDesc{
				{"sgName", ``},     // string
				{"joinerName", ``}, // string
				{"myInfo", ``},     // syncbase.SyncgroupMemberInfo
			},
			OutArgs: []rpc.ArgDesc{
				{"sg", ``},      // Syncgroup
				{"version", ``}, // string
				{"genvec", ``},  // GenVector
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Read"))},
		},
		{
			Name: "HaveBlob",
			Doc:  "// HaveBlob verifies that the peer has the requested blob, and if\n// present, returns its size.  Otherwise, it returns -1, and the location\n// hints (the Signpost) that the peer has for the blob, filtered to\n// include only data the caller is permitted to see:\n// + Device D reveals a syncgroup SG to the caller C iff\n//   - D is in SG, and\n//   - SG is in the Signpost, and\n//   - at least one of:\n//     - SG is not private, or\n//     - C has permission to join SG.\n// + Device D reveals a location hint L to caller C iff\n//   there is a syncgroup SG such that\n//   - D is in SG, and\n//   - SG is in the Signpost, and\n//   - L is in SG, and\n//   - at least one of:\n//     - SG is not private, or\n//     - C has permission to join SG, or\n//     - L is a blob server in SG.",
			InArgs: []rpc.ArgDesc{
				{"br", ``}, // syncbase.BlobRef
			},
			OutArgs: []rpc.ArgDesc{
				{"size", ``},     // int64
				{"signpost", ``}, // Signpost
			},
		},
		{
			Name: "FetchBlob",
			Doc:  "// FetchBlob fetches the requested blob.\n// It returns a number of blob ownership shares that the server hopes\n// the client will accept using the AcceptedBlobOwnership() call.",
			InArgs: []rpc.ArgDesc{
				{"br", ``},             // syncbase.BlobRef
				{"mySgPriorities", ``}, // SgPriorities
			},
			OutArgs: []rpc.ArgDesc{
				{"shares", ``}, // BlobSharesBySyncgroup
			},
		},
		{
			Name: "FetchBlobRecipe",
			Doc:  "// Methods for incremental blob transfer. The transfer starts with the\n// receiver making a FetchBlobRecipe call to the sender for a given\n// BlobRef. The sender, in turn, sends the chunk hashes of all the\n// chunks that make up the requested blob (blob recipe). The receiver\n// looks up the chunk hashes in its local blob store, and identifies the\n// missing ones. The receiver then fetches the missing chunks using a\n// FetchChunks call from the sender. Finally, the receiver finishes the\n// blob fetch by combining the chunks obtained over the network with the\n// already available local chunks as per the blob recipe.\n// callerName is the syncbase Id of the caller, expressed as a string.\n// FetchBlobRecipe returns a number of blob ownership shares that the\n// server hopes the client will accept for each syncgroup using the\n// AcceptedBlobOwnership() call.",
			InArgs: []rpc.ArgDesc{
				{"br", ``},             // syncbase.BlobRef
				{"callerName", ``},     // string
				{"mySgPriorities", ``}, // SgPriorities
			},
			OutArgs: []rpc.ArgDesc{
				{"shares", ``}, // BlobSharesBySyncgroup
			},
		},
		{
			Name: "FetchChunks",
		},
		{
			Name: "RequestTakeBlob",
			Doc:  "// RequestTakeBlob indicates that the caller wishes the server to take\n// some blob ownership shares for various syncgroups for the specified blob.\n// If the server chooses to act on the request, it may call FetchBlob/FetchBlobRecipe,\n// and ultimately AcceptedBlobOwnership().\n// callerName is the syncbase Id of the caller, expressed as a string.",
			InArgs: []rpc.ArgDesc{
				{"br", ``},         // syncbase.BlobRef
				{"callerName", ``}, // string
				{"shares", ``},     // BlobSharesBySyncgroup
			},
		},
		{
			Name: "AcceptedBlobOwnership",
			Doc:  "// AcceptedBlobOwnership tells the server that the client callerName (a\n// syncbase Id expressed as a string) has accepted blob ownership of a\n// specified number of shares for blob br.  The server may decrement\n// its share count by up to this number.  It is safe for the server to\n// decrement its share count by fewer than the number of shares another\n// device has taken responsibility for, but unsafe to decrement it by\n// more than that that number.  It returns a hint as to whether the\n// server is likely to keep the blob itself, plus its syncbase Id\n// expressed as a string.",
			InArgs: []rpc.ArgDesc{
				{"br", ``},         // syncbase.BlobRef
				{"callerName", ``}, // string
				{"shares", ``},     // BlobSharesBySyncgroup
			},
			OutArgs: []rpc.ArgDesc{
				{"serverName", ``},  // string
				{"keepingBlob", ``}, // bool
			},
		},
	},
}

// SyncGetDeltasServerStream is the server stream for Sync.GetDeltas.
type SyncGetDeltasServerStream interface {
	// SendStream returns the send side of the Sync.GetDeltas server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item DeltaResp) error
	}
}

// SyncGetDeltasServerCall represents the context passed to Sync.GetDeltas.
type SyncGetDeltasServerCall interface {
	rpc.ServerCall
	SyncGetDeltasServerStream
}

// SyncGetDeltasServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements SyncGetDeltasServerCall.
type SyncGetDeltasServerCallStub struct {
	rpc.StreamServerCall
}

// Init initializes SyncGetDeltasServerCallStub from rpc.StreamServerCall.
func (s *SyncGetDeltasServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// SendStream returns the send side of the Sync.GetDeltas server stream.
func (s *SyncGetDeltasServerCallStub) SendStream() interface {
	Send(item DeltaResp) error
} {
	return implSyncGetDeltasServerCallSend{s}
}

type implSyncGetDeltasServerCallSend struct {
	s *SyncGetDeltasServerCallStub
}

func (s implSyncGetDeltasServerCallSend) Send(item DeltaResp) error {
	return s.s.Send(item)
}

// SyncFetchBlobServerStream is the server stream for Sync.FetchBlob.
type SyncFetchBlobServerStream interface {
	// SendStream returns the send side of the Sync.FetchBlob server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item []byte) error
	}
}

// SyncFetchBlobServerCall represents the context passed to Sync.FetchBlob.
type SyncFetchBlobServerCall interface {
	rpc.ServerCall
	SyncFetchBlobServerStream
}

// SyncFetchBlobServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements SyncFetchBlobServerCall.
type SyncFetchBlobServerCallStub struct {
	rpc.StreamServerCall
}

// Init initializes SyncFetchBlobServerCallStub from rpc.StreamServerCall.
func (s *SyncFetchBlobServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// SendStream returns the send side of the Sync.FetchBlob server stream.
func (s *SyncFetchBlobServerCallStub) SendStream() interface {
	Send(item []byte) error
} {
	return implSyncFetchBlobServerCallSend{s}
}

type implSyncFetchBlobServerCallSend struct {
	s *SyncFetchBlobServerCallStub
}

func (s implSyncFetchBlobServerCallSend) Send(item []byte) error {
	return s.s.Send(item)
}

// SyncFetchBlobRecipeServerStream is the server stream for Sync.FetchBlobRecipe.
type SyncFetchBlobRecipeServerStream interface {
	// SendStream returns the send side of the Sync.FetchBlobRecipe server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item ChunkHash) error
	}
}

// SyncFetchBlobRecipeServerCall represents the context passed to Sync.FetchBlobRecipe.
type SyncFetchBlobRecipeServerCall interface {
	rpc.ServerCall
	SyncFetchBlobRecipeServerStream
}

// SyncFetchBlobRecipeServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements SyncFetchBlobRecipeServerCall.
type SyncFetchBlobRecipeServerCallStub struct {
	rpc.StreamServerCall
}

// Init initializes SyncFetchBlobRecipeServerCallStub from rpc.StreamServerCall.
func (s *SyncFetchBlobRecipeServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// SendStream returns the send side of the Sync.FetchBlobRecipe server stream.
func (s *SyncFetchBlobRecipeServerCallStub) SendStream() interface {
	Send(item ChunkHash) error
} {
	return implSyncFetchBlobRecipeServerCallSend{s}
}

type implSyncFetchBlobRecipeServerCallSend struct {
	s *SyncFetchBlobRecipeServerCallStub
}

func (s implSyncFetchBlobRecipeServerCallSend) Send(item ChunkHash) error {
	return s.s.Send(item)
}

// SyncFetchChunksServerStream is the server stream for Sync.FetchChunks.
type SyncFetchChunksServerStream interface {
	// RecvStream returns the receiver side of the Sync.FetchChunks server stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() ChunkHash
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the Sync.FetchChunks server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item ChunkData) error
	}
}

// SyncFetchChunksServerCall represents the context passed to Sync.FetchChunks.
type SyncFetchChunksServerCall interface {
	rpc.ServerCall
	SyncFetchChunksServerStream
}

// SyncFetchChunksServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements SyncFetchChunksServerCall.
type SyncFetchChunksServerCallStub struct {
	rpc.StreamServerCall
	valRecv ChunkHash
	errRecv error
}

// Init initializes SyncFetchChunksServerCallStub from rpc.StreamServerCall.
func (s *SyncFetchChunksServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// RecvStream returns the receiver side of the Sync.FetchChunks server stream.
func (s *SyncFetchChunksServerCallStub) RecvStream() interface {
	Advance() bool
	Value() ChunkHash
	Err() error
} {
	return implSyncFetchChunksServerCallRecv{s}
}

type implSyncFetchChunksServerCallRecv struct {
	s *SyncFetchChunksServerCallStub
}

func (s implSyncFetchChunksServerCallRecv) Advance() bool {
	s.s.valRecv = ChunkHash{}
	s.s.errRecv = s.s.Recv(&s.s.valRecv)
	return s.s.errRecv == nil
}
func (s implSyncFetchChunksServerCallRecv) Value() ChunkHash {
	return s.s.valRecv
}
func (s implSyncFetchChunksServerCallRecv) Err() error {
	if s.s.errRecv == io.EOF {
		return nil
	}
	return s.s.errRecv
}

// SendStream returns the send side of the Sync.FetchChunks server stream.
func (s *SyncFetchChunksServerCallStub) SendStream() interface {
	Send(item ChunkData) error
} {
	return implSyncFetchChunksServerCallSend{s}
}

type implSyncFetchChunksServerCallSend struct {
	s *SyncFetchChunksServerCallStub
}

func (s implSyncFetchChunksServerCallSend) Send(item ChunkData) error {
	return s.s.Send(item)
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*GenVector)(nil))
	vdl.Register((*Knowledge)(nil))
	vdl.Register((*LogRecMetadata)(nil))
	vdl.Register((*LogRec)(nil))
	vdl.Register((*GroupId)(nil))
	vdl.Register((*SyncgroupStatus)(nil))
	vdl.Register((*Syncgroup)(nil))
	vdl.Register((*SgDeltaReq)(nil))
	vdl.Register((*DataDeltaReq)(nil))
	vdl.Register((*DeltaReq)(nil))
	vdl.Register((*DeltaResp)(nil))
	vdl.Register((*SgPriority)(nil))
	vdl.Register((*SgPriorities)(nil))
	vdl.Register((*DeltaFinalResp)(nil))
	vdl.Register((*ChunkHash)(nil))
	vdl.Register((*ChunkData)(nil))
	vdl.Register((*TimeReq)(nil))
	vdl.Register((*TimeResp)(nil))
	vdl.Register((*BlobSharesBySyncgroup)(nil))
	vdl.Register((*LocationData)(nil))
	vdl.Register((*PeerToLocationDataMap)(nil))
	vdl.Register((*Signpost)(nil))

	// Set error format strings.
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrDupSyncgroupPublish.ID), "{1:}{2:} duplicate publish on syncgroup: {3}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrConnFail.ID), "{1:}{2:} connection to peer failed{:_}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrBrokenCrConnection.ID), "{1:}{2:} CrConnection stream to client does not exist or is broken")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrDbOffline.ID), "{1:}{2:} database {3} is offline and cannot be synced{:_}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrGetTimeFailed.ID), "{1:}{2:} GetTime failed{:_}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrNotAdmin.ID), "{1:}{2:} not an admin of the syncgroup")

	return struct{}{}
}
